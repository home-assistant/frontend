<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="./entity/ha-chart-base.html">

<dom-module id='state-history-chart-line'>
  <template>
      <ha-chart-base publish data="[[chartData]]"></ha-chart-base>
  </template>
</dom-module>
<script>
'use strict';

class StateHistoryChartLine extends Polymer.Element {
  static get is() { return 'state-history-chart-line'; }
  static get properties() {
    return {
      data: {
        type: Object,
      },

      unit: {
        type: String,
      },

      isSingleDevice: {
        type: Boolean,
        value: false,
      },

      endTime: {
        type: Object,
      },
    };
  }
  static get observers() {
    return ['dataChanged(data, endTime)'];
  }

  connectedCallback() {
    super.connectedCallback();
    this._isAttached = true;
    this.drawChart();
    // this.addEventListener('iron-resize', () => {
    //   this.async(this.drawChart, 10);
    // });
  }

  dataChanged() {
    this.drawChart();
  }

  drawChart() {
    var unit = this.unit;
    var deviceStates = this.data;
    var options;
    var startTime;
    var endTime;
    var dataTables;
    var daysDelta;
    var xs;
    var xt;

    if (!this._isAttached) {
      return;
    }

    if (deviceStates.length === 0) {
      return;
    }

    function safeParseFloat(value) {
      var parsed = parseFloat(value);
      // isFinite(NaN) === False
      return isFinite(parsed) ? parsed : null;
    }

    options = {
      backgroundColor: '#fafafa',
      legend: { position: 'top' },
      interpolateNulls: true,
      titlePosition: 'none',
      vAxes: {
        // Adds units to the left hand side of the graph
        0: { title: unit },
      },
      hAxis: {
        format: 'H:mm',
      },
      chartArea: { left: '60', width: '95%' },
      explorer: {
        actions: ['dragToZoom', 'rightClickToReset', 'dragToPan'],
        keepInBounds: true,
        axis: 'horizontal',
        maxZoomIn: 0.1,
      },
    };

    if (this.isSingleDevice) {
      options.legend.position = 'none';
      options.vAxes[0].title = null;
      options.chartArea.left = 40;
      options.chartArea.height = '80%';
      options.chartArea.top = 5;
    }

    startTime = new Date(Math.min.apply(null, deviceStates.map(function (states) {
      return new Date(states.states[0].last_changed);
    })));

    endTime = this.endTime ||
      new Date(Math.max.apply(null, deviceStates.map(states =>
        new Date(states.states[states.states.length - 1].last_changed))));
    if (endTime > new Date()) {
      endTime = new Date();
    }

    daysDelta = (endTime - startTime) / (24 * 3600 * 1000);
    // Avoid rounding up when the API returns a few extra seconds.
    if (daysDelta > 30.1) {
      options.hAxis.format = 'MMM d';
    } else if (daysDelta > 3.1) {
      options.hAxis.format = 'EEE, MMM d';
    } else if (daysDelta > 1.1) {
      options.hAxis.format = 'EEE, MMM d, H:mm';
    }

    dataTables = [];
    xs = {};
    xt = {};

    deviceStates.forEach(function (states) {
      var domain = states.domain;
      var name = states.name;
      // array containing [value1, value2, etc]
      var prevValues;
      // var prevTime;
      var hasTargetRange;
      var processState;
      var noInterpolations;
      var data = [];
      var nameX = name + '__x';
      var dataX = [nameX];


      function pushData(timestamp, values) {
        if (timestamp > endTime) {
          // Drop datapoints that are after the requested endTime. This could happen if
          // endTime is "now" and client time is not in sync with server time.
          return;
        }
        data.forEach(function (d, i) { d.push(values[i]); });
        dataX.push(timestamp);
        prevValues = values;
        // prevTime = timestamp;
      }

      function addColumn(nameY, type) {
        if (!type) {
          type = 'line';
        }
        xs[nameY] = nameX;
        xt[nameY] = type;
        data.push([nameY]);
      }

      if (domain === 'thermostat' || domain === 'climate') {
        // We differentiate between thermostats that have a target temperature
        // range versus ones that have just a target temperature

        // Using step chart by step-after so manually interpolation not needed.
        hasTargetRange = states.states.reduce(function (cum, cur) {
          return cum || cur.attributes.target_temp_high !== cur.attributes.target_temp_low;
        }, false);

        addColumn(name + ' current temperature', 'line');
        addColumn(name + ' heating', 'area');

        if (hasTargetRange) {
          addColumn(name + ' target temperature high', 'step');
          addColumn(name + ' target temperature low', 'step');

          noInterpolations = [false, true, true];
        } else {
          addColumn(name + ' target temperature', 'step');
        }
        processState = function (state) {
          var curTemp = safeParseFloat(state.attributes.current_temperature);
          var heating = state.state === 'heat' ? curTemp : null;
          if (hasTargetRange) {
            var targetHigh = safeParseFloat(state.attributes.target_temp_high);
            var targetLow = safeParseFloat(state.attributes.target_temp_low);
            pushData(
              new Date(state.last_changed),
              [curTemp, heating, targetHigh, targetLow]
            );
          } else {
            var target = safeParseFloat(state.attributes.temperature);
            pushData(new Date(state.last_changed), [curTemp, heating, target]);
          }
        };

        states.states.forEach(processState);
      } else {
        addColumn(name);

        // Only disable interpolation for sensors
        noInterpolations = domain !== 'sensor' && [true];

        states.states.forEach(function (state) {
          var value = safeParseFloat(state.state);
          pushData(new Date(state.last_changed), [value], noInterpolations);
        });
      }

      // Add an entry for final values
      pushData(endTime, prevValues, false);

      // Concat two arrays
      Array.prototype.push.apply(dataTables, data);
      dataTables.push(dataX);
    });
    var chartData = {
      xs: xs,
      data: dataTables,
      type: 'line',
      types: xt,
      title: unit
    };

    this.chartData = chartData;
  }
}
customElements.define(StateHistoryChartLine.is, StateHistoryChartLine);
</script>
