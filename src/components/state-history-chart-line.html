<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="./entity/ha-chart-base.html">

<dom-module id='state-history-chart-line'>
  <template>
      <ha-chart-base publish data="[[chartData]]"></ha-chart-base>
  </template>
</dom-module>
<script>
'use strict';

class StateHistoryChartLine extends Polymer.Element {
  static get is() { return 'state-history-chart-line'; }
  static get properties() {
    return {
      data: {
        type: Object,
      },

      unit: {
        type: String,
      },

      isSingleDevice: {
        type: Boolean,
        value: false,
      },

      endTime: {
        type: Object,
      },
    };
  }
  static get observers() {
    return ['dataChanged(data, endTime)'];
  }

  connectedCallback() {
    super.connectedCallback();
    this._isAttached = true;
    this.drawChart();
    // this.addEventListener('iron-resize', () => {
    //   this.async(this.drawChart, 10);
    // });
  }

  dataChanged() {
    this.drawChart();
  }

  drawChart() {
    var colorArray = ['red', 'blue', 'green', 'navy', 'purple', 'orange'];
    var colorId = 0;
    var getColor = function () {
      return colorArray[colorId++];
    };
    function getColorAlpha(str, alpha) {
      return Color(str).alpha(1 - alpha).rgbaString();
    }
    var unit = this.unit;
    var deviceStates = this.data;
    // var options;
    var startTime;
    var endTime;
    var datasets;
    var daysDelta;

    if (!this._isAttached) {
      return;
    }

    if (deviceStates.length === 0) {
      return;
    }

    function safeParseFloat(value) {
      var parsed = parseFloat(value);
      // isFinite(NaN) === False
      return isFinite(parsed) ? parsed : null;
    }

    startTime = new Date(Math.min.apply(null, deviceStates.map(function (states) {
      return new Date(states.states[0].last_changed);
    })));

    endTime = this.endTime ||
      new Date(Math.max.apply(null, deviceStates.map(states =>
        new Date(states.states[states.states.length - 1].last_changed))));
    if (endTime > new Date()) {
      endTime = new Date();
    }

    daysDelta = (endTime - startTime) / (24 * 3600 * 1000);
    // Avoid rounding up when the API returns a few extra seconds.
    // if (daysDelta > 30.1) {
    //   options.hAxis.format = 'MMM d';
    // } else if (daysDelta > 3.1) {
    //   options.hAxis.format = 'EEE, MMM d';
    // } else if (daysDelta > 1.1) {
    //   options.hAxis.format = 'EEE, MMM d, H:mm';
    // }

    datasets = [];

    deviceStates.forEach(function (states) {
      var domain = states.domain;
      var name = states.name;
      // array containing [value1, value2, etc]
      var prevValues;
      // var prevTime;
      var hasTargetRange;
      var processState;
      var data = [];


      function pushData(timestamp, datavalues) {
        if (!datavalues) return;
        if (timestamp > endTime) {
          // Drop datapoints that are after the requested endTime. This could happen if
          // endTime is "now" and client time is not in sync with server time.
          return;
        }
        data.forEach(function (d, i) {
          d.data.push({ x: timestamp, y: datavalues[i] });
        });
        prevValues = datavalues;
        // prevTime = timestamp;
      }

      function addColumn(nameY, type) {
        var fill = false;
        var step = false;
        var color = getColor();
        var bgColor = color;
        if (!type) {
          type = 'line';
        }
        if (type === 'area') {
          fill = 'origin';
          bgColor = getColorAlpha(color, 0.65);
        } else if (type === 'step') {
          step = 'after';
        }
        data.push({
          label: nameY,
          fill: fill,
          backgroundColor: bgColor,
          borderColor: color,
          steppedLine: step,
          pointRadius: 0,
          data: [],
          unitText: unit
        });
      }

      if (domain === 'thermostat' || domain === 'climate') {
        // We differentiate between thermostats that have a target temperature
        // range versus ones that have just a target temperature

        // Using step chart by step-after so manually interpolation not needed.
        hasTargetRange = states.states.some(state => state.attributes &&
          state.attributes.target_temp_high !== state.attributes.target_temp_low);

        addColumn(name + ' current temperature', 'line');
        addColumn(name + ' heating', 'area');

        if (hasTargetRange) {
          addColumn(name + ' target temperature high', 'step');
          addColumn(name + ' target temperature low', 'step');
        } else {
          addColumn(name + ' target temperature', 'step');
        }
        processState = function (state) {
          if (!state.attributes) return;
          var curTemp = safeParseFloat(state.attributes.current_temperature);
          var heating = state.state === 'heat' ? curTemp : null;
          if (hasTargetRange) {
            var targetHigh = safeParseFloat(state.attributes.target_temp_high);
            var targetLow = safeParseFloat(state.attributes.target_temp_low);
            pushData(
              new Date(state.last_changed),
              [curTemp, heating, targetHigh, targetLow]
            );
          } else {
            var target = safeParseFloat(state.attributes.temperature);
            pushData(new Date(state.last_changed), [curTemp, heating, target]);
          }
        };

        states.states.forEach(processState);
      } else {
        addColumn(name);

        // Only disable interpolation for sensors
        var columnStyle = domain !== 'sensor' ? 'line' : 'step';
        addColumn(name, columnStyle);

        states.states.forEach(function (state) {
          var value = safeParseFloat(state.state);
          pushData(new Date(state.last_changed), [value]);
        });
      }

      // Add an entry for final values
      pushData(endTime, prevValues, false);

      // Concat two arrays
      Array.prototype.push.apply(datasets, data);
    });

    var chartOptions = {
      type: 'line',
      options: {
        title: {
          display: false,
          text: unit
        },
        scales: {
          xAxes: [{
            type: 'time',
            ticks: {
              major: {
                fontStyle: 'bold',
              },
            },
          }],
          yAxes: [{
            // offset: true,
            ticks: {
              maxTicksLimit: 7,
              // padding: 10,
            },
            // Add space to prevent cut-off.
            afterDataLimits: function (axis) {
              var min = axis.min;
              var max = axis.max;
              if (isFinite(min) && isFinite(max)) {
                var padding = (max - min) * 0.05;
                axis.min -= padding;
                axis.max += padding;
              }
            },
          }],
        },
        // Need more invastigate to tooltip point choose.
        tooltips: {
          // mode: 'index',
          mode: 'neareach',
          // filter: 
        },
        hover: {
          mode: 'neareach',
        },
        elements: {
          line: {
            tension: 0.1,
            pointRadius: 0,
            borderWidth: 1.5,
            // pointHoverRadius: 6,
          },
          point: {
            hitRadius: 5,
          }
        },
        plugins: {
          filler: {
            propagate: true,
          }
        },
      },
      data: {
        labels: [],
        datasets: datasets
      }
    };
    this.chartData = chartOptions;
  }
}
customElements.define(StateHistoryChartLine.is, StateHistoryChartLine);
</script>
