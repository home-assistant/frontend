<link rel='import' href='../../../bower_components/polymer/polymer-element.html'>

<dom-module id="ha-chart-base">
  <template>
    <style>
      #chartCanvas{
        user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
      }
      #chartTooltip {
        opacity: 1;
        position: absolute;
        background: rgba(0, 0, 0, .7);
        color: white;
        border-radius: 3px;
        -webkit-transition: all .1s ease;
        transition: all .1s ease;
        pointer-events: none;
        -webkit-transform: translate(-50%, 0);
        transform: translate(-50%, 0);
        z-index: 1000;
        width: 200px;
      }
      #chartTooltip tr span{
        display: inline-block;
        width: 10px;
        height: 10px;
        margin-right: 10px;
        border-width: 3px;
      }
    </style>
    <div id="chartTarget" style="height:0; width:100%">
      <canvas id="chartCanvas"></canvas>
      <div id="chartTooltip" style="opacity:0">
        <table>
          <thead><tr><th id="tooltipTitle"></th></tr></thead>
          <tbody id="tooltipBody"></tbody>
        </table>
      </div>
    </div>
  </template>
</dom-module>
<script src="../../../bower_components/moment/moment.js"></script>
<script src="../../../bower_components/chart.js/dist/Chart.js"></script>
<script src="../../../bower_components/chartjs-chart-timeline/timeline.js"></script>
<script>
// eslint-disable-next-line no-unused-vars
/* global Chart moment Color */
class HaChartBase extends
  Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
  get chart() {
    return this._chart;
  }
  static get is() { return 'ha-chart-base'; }
  static get properties() {
    return {
      publish: {
        type: Boolean,
        observer: 'onPropsChange'
      },
      data: {
        type: Object,
        observer: 'onPropsChange'
      },
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.connected = true;
    this.addEventListener('iron-resize', () => {
      setTimeout(this.resizeChart.bind(this), 1);
    });
    if (!this._chart) {
      this.onPropsChange();
    }
    // setTimeout(this.resizeChart.bind(this), 1);
  }
  onPropsChange() {
    if (!this.connected || !this.publish || !this.data) {
      return;
    }
    this.drawChart();
  }
  _customTooltips(tooltip) {
    // Tooltip Element
    var tooltipEl = this._tooltipEl;
    var isTimeline = this._isTimeline;
    // Hide if no tooltip
    if (tooltip.opacity === 0) {
      tooltipEl.style.opacity = 0;
      return;
    }
    // Set caret Position
    tooltipEl.classList.remove('above', 'below', 'no-transform');
    if (tooltip.yAlign) {
      tooltipEl.classList.add(tooltip.yAlign);
    } else {
      tooltipEl.classList.add('no-transform');
    }
    function getBody(bodyItem) {
      return bodyItem.lines;
    }
    // Set Text
    if (tooltip.body) {
      var titleLines = tooltip.title || [];
      var bodyLines = tooltip.body.map(getBody);
      titleLines.forEach(function (title) {
        var str1;
        if (title instanceof Date) {
          str1 = moment(title).format('L LTS');
        } else if (title instanceof moment) {
          str1 = title.format('L LTS');
        } else {
          str1 = title;
        }
        this.$.tooltipTitle.innerText = str1;
      }, this);
      var tBody = this.$.tooltipBody;
      while (tBody.hasChildNodes()) {
        tBody.removeChild(tBody.lastChild);
      }
      var ce = x => document.createElement(x);
      bodyLines.forEach(function (body, i) {
        var colors = tooltip.labelColors[i];
        var span = ce('span');
        span.style = ('background:' + colors.backgroundColor +
          '; border-color:' + colors.borderColor);
        var tableTr = ce('tr');
        var tableTd = ce('td');
        var tableText;
        tableTr.appendChild(tableTd);
        tableTd.appendChild(span);
        if (isTimeline) {
          tableText = document.createTextNode(body[0]);
          tableTd.appendChild(tableText);
          for (var loopI = 1; loopI < body.length; loopI++) {
            tableTd.appendChild(ce('br'));
            tableText = document.createTextNode(body[loopI]);
            tableTd.appendChild(tableText);
          }
        } else {
          tableText = document.createTextNode(body);
          tableTd.appendChild(tableText);
        }
        tBody.appendChild(tableTr);
      }, this);
    }
    var positionX = this._chart.canvas.offsetLeft + tooltip.caretX;
    var positionY = this._chart.canvas.offsetTop + tooltip.caretY;
    var parentWidth = this.$.chartTarget.clientWidth;
    if (positionX + 100 > parentWidth) {
      positionX = parentWidth - 100;
    } else if (positionX < 100) {
      positionX = 100;
    }
    // Display, position, and set styles for font
    tooltipEl.style.opacity = 1;
    tooltipEl.style.top = positionY + 'px';
    tooltipEl.style.left = positionX + 'px';
    tooltipEl.style.padding = tooltip.yPadding + 'px ' + tooltip.xPadding + 'px';
  }
  _chartGetIntersection(chart, e, options) {
    var getRange = {
      x: (a, b) => Math.abs(a.x - b.x),
      y: (a, b) => Math.abs(a.y - b.y),
      // eslint-disable-next-line no-restricted-properties
      xy: (a, b) => Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2),
    };
    var getRangeMax = {
      x: r => r,
      y: r => r,
      xy: r => r * r,
    };
    var position;
    if (e.native) {
      position = {
        x: e.x,
        y: e.y
      };
    } else {
      position = Chart.helpers.getRelativePosition(e, chart);
    }
    var elements = [];
    var elementsRange = [];
    var datasets = chart.data.datasets;
    var meta;
    options.axis = options.axis || 'xy';
    var rangeFunc = getRange[options.axis];
    var rangeMaxFunc = getRangeMax[options.axis];

    for (var i = 0, ilen = datasets.length; i < ilen; ++i) {
      if (!chart.isDatasetVisible(i)) {
        continue;
      }

      meta = chart.getDatasetMeta(i);
      for (var j = 0, jlen = meta.data.length; j < jlen; ++j) {
        var element = meta.data[j];
        if (!element._view.skip) {
          var vm = element._view;
          var range = rangeFunc(vm, position);
          var oldRange = elementsRange[i];
          if (range < rangeMaxFunc(vm.radius + vm.hitRadius)) {
            if (oldRange === undefined || oldRange > range) {
              elementsRange[i] = range;
              elements[i] = element;
            }
          }
        }
      }
    }
    var ret = elements.filter(function (n) { return n !== undefined; });
    return ret;
  }
  drawChart() {
    var data = this.data.data;
    var ctx = this.$.chartCanvas;


    if ((!data.datasets || !data.datasets.length) && !this._chart) {
      return;
    }
    if (this.data.type !== 'timeline' && data.datasets.length > 0) {
      var cnt = 0;
      cnt = data.datasets.length;
      var colors = HaChartBase.getColorList(cnt);
      for (var loopI = 0; loopI < cnt; loopI++) {
        data.datasets[loopI].borderColor = colors[loopI].rgbString();
        data.datasets[loopI].backgroundColor = colors[loopI].alpha(0.65).rgbaString();
      }
    }

    if (this._chart) {
      this._customTooltips({ opacity: 0 });
      this._chart.data = data;
      this._chart.update({ duration: 0 });
      this.resizeChart();
    } else {
      if (!data.datasets) {
        return;
      }
      if (!Chart.Interaction.modes.neareach) {
        Chart.Interaction.modes.neareach = this._chartGetIntersection.bind(this);
      }
      var colorList = this.data.colors ? this.data.colors.staticColors : undefined;
      var colorIndex = this.data.colors ? this.data.colors.staticColorIndex : undefined;
      this._colorFunc = HaChartBase.getColorGenerator(colorList, colorIndex);
      // chartTarget.style.height = targetHeight;
      // chartTarget.height = targetHeight;
      this._tooltipEl = this.$.chartTooltip;
      this._customTooltips({ opacity: 0 });
      var options = {
        responsive: true,
        maintainAspectRatio: false,
        colorFunction: this._colorFunc,
        animation: {
          duration: 0,
        },
        hover: {
          animationDuration: 0,
        },
        responsiveAnimationDuration: 0,
        tooltips: {
          enabled: false,
          custom: this._customTooltips.bind(this),
        },
        legend: {
          display: false,
        },
      };
      options = Chart.helpers.merge(options, this.data.options);
      if (this.data.type === 'timeline') {
        this._isTimeline = true;
      }
      this.$.chartTarget.style.height = '200px';
      this.$.chartTarget.height = '200px';
      this._chart = new Chart(ctx, {
        type: this.data.type,
        data: this.data.data,
        options: options
      });
      // Async resize after dom update
      setTimeout(this.resizeChart.bind(this), 1);
    }
  }
  resizeChart() {
    if (!this._chart) return;
    var options = this.data;
    var data = options.data;

    var chartTarget = this.$.chartTarget;

    if (this._isTimeline) {
      if (data.datasets.length === 0) {
        chartTarget.style.height = '0px';
        chartTarget.height = '0px';
        this._chart.resize();
      } else {
        var axis = this._chart.boxes.filter(x => x.position === 'bottom')[0];
        if (axis && axis.height > 0) {
          this._axisHeight = axis.height;
        }
        if (!this._axisHeight) {
          chartTarget.style.height = '100px';
          chartTarget.height = '100px';
          this._chart.resize();
          axis = this._chart.boxes.filter(x => x.position === 'bottom')[0];
          if (axis && axis.height > 0) {
            this._axisHeight = axis.height;
          }
        }
        if (this._axisHeight) {
          var cnt = data.datasets.length;
          var targetHeight = ((30 * cnt) + this._axisHeight) + 'px';
          if (chartTarget.style.height !== targetHeight) {
            chartTarget.style.height = targetHeight;
            chartTarget.height = targetHeight;
          }
          this._chart.resize();
        }
      }
    } else {
      this._chart.resize();
    }
  }
  static getColorList(count) {
    var processL = false;
    if (count > 10) {
      processL = true;
      count = Math.ceil(count / 2);
    }
    var h1 = 360 / count;
    var result = [];
    for (var loopI = 0; loopI < count; loopI++) {
      result[loopI] = Color().hsl(h1 * loopI, 80, 38);
      if (processL) {
        result[loopI + count] = Color().hsl(h1 * loopI, 80, 62);
      }
    }
    return result;
  }
  static getColorGenerator(staticColors, startIndex) {
    // Known colors for static data,
    // should add for very common state string manually.
    // Distribute the color data like complete binary tree
    function getColorRange(x) {
      if (x === 0) return 0;
      if (x === 1) return 0.5;
      var y = Math.floor(Math.log(x) / Math.LN2);
      // eslint-disable-next-line no-restricted-properties
      var e = Math.pow(2, y);
      var n = x - e;
      var a;
      if (y % 2 === 1) {
        if (n % 2 === 0) {
          a = n + 1;
        } else {
          a = n + e;
        }
      } else {
        // eslint-disable-next-line no-lonely-if
        if (n % 2 === 0) {
          a = e - n - 1;
        } else {
          a = (e + e) - n;
        }
      }
      return a / (e + e);
    }
    function getColorIndex(idx) {
      var hIndex = Math.floor(idx / 6);
      var h1 = getColorRange(hIndex);
      var c1 = (h1 + (idx % 3)) * 120;
      var l1 = idx % 6 < 3 ? 62 : 38;
      return Color().hsl(c1, 75, l1);
    }
    var colorDict = {};
    var colorIndex = 0;
    if (startIndex > 0) colorIndex = startIndex;
    if (staticColors) {
      Object.keys(staticColors).forEach(function (c) {
        var c1 = staticColors[c];
        if (isFinite(c1)) {
          colorDict[c.toLowerCase()] = getColorIndex(c1);
        } else {
          colorDict[c.toLowerCase()] = Color(staticColors[c]);
        }
      });
    }
    // Custom color assign
    function getColor(name) {
      var ret;
      var name1 = name.toLowerCase();
      if (ret === undefined) {
        ret = colorDict[name1];
      }
      if (ret === undefined) {
        ret = getColorIndex(colorIndex);
        colorIndex++;
        colorDict[name1] = ret;
      }
      return ret;
    }
    return getColor;
  }
}
customElements.define(HaChartBase.is, HaChartBase);
</script>
