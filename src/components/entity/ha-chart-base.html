<link rel='import' href='../../../bower_components/polymer/polymer-element.html'>

<dom-module id="ha-chart-base">
  <template>
    <style>
      #chartCanvas{
        user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
      }
      #chartTooltip {
        opacity: 1;
        position: absolute;
        background: rgba(0, 0, 0, .7);
        color: white;
        border-radius: 3px;
        -webkit-transition: all .1s ease;
        transition: all .1s ease;
        pointer-events: none;
        -webkit-transform: translate(-50%, 0);
        transform: translate(-50%, 0);
        z-index: 1000;
        width: 200px;
      }
      #chartTooltip tr span{
        display: inline-block;
        width: 10px;
        height: 10px;
        margin-right: 10px;
        border-width: 3px;
      }
    </style>
    <div id="chartTarget" style="height:0; width:100%">
      <canvas id="chartCanvas"></canvas>
      <div id="chartTooltip" style="opacity:0">
        <table>
          <thead><tr><th id="tooltipTitle"></th></tr></thead>
          <tbody id="tooltipBody"></tbody>
        </table>
      </div>
    </div>
  </template>
</dom-module>
<script src="../../../bower_components/moment/moment.js"></script>
<script src="../../../bower_components/chart.js/dist/Chart.js"></script>
<script src="../../../bower_components/chartjs-chart-timeline/timeline.js"></script>
<script>
/* global Chart moment */// eslint-disable-line no-unused-vars
class HaChartBase extends
  Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
  get chart() {
    return this._chart;
  }
  static get is() { return 'ha-chart-base'; }
  static get properties() {
    return {
      publish: {
        type: Boolean,
        observer: 'onPropsChange'
      },
      data: {
        type: Object,
        observer: 'onPropsChange'
      },
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.connected = true;
    this.addEventListener('iron-resize', () => {
      setTimeout(this.resizeChart.bind(this), 1);
    });
    if (!this._chart) {
      this.onPropsChange();
    }
    // setTimeout(this.resizeChart.bind(this), 1);
  }
  onPropsChange() {
    if (!this.connected || !this.publish || !this.data) {
      return;
    }
    this.drawChart();
  }
  _customTooltips(tooltip) {
    // Tooltip Element
    var tooltipEl = this._tooltipEl;
    // Hide if no tooltip
    if (tooltip.opacity === 0) {
      tooltipEl.style.opacity = 0;
      return;
    }
    // Set caret Position
    tooltipEl.classList.remove('above', 'below', 'no-transform');
    if (tooltip.yAlign) {
      tooltipEl.classList.add(tooltip.yAlign);
    } else {
      tooltipEl.classList.add('no-transform');
    }
    function getBody(bodyItem) {
      return bodyItem.lines;
    }
    // Set Text
    if (tooltip.body) {
      var titleLines = tooltip.title || [];
      var bodyLines = tooltip.body.map(getBody);
      titleLines.forEach(function (title) {
        var str1;
        if (title instanceof Date) {
          str1 = moment(title).format('L LTS');
        } else if (title instanceof moment) {
          str1 = title.format('L LTS');
        } else {
          str1 = title;
        }
        this.$.tooltipTitle.innerText = str1;
      }, this);
      var tBody = this.$.tooltipBody;
      while (tBody.hasChildNodes()) {
        tBody.removeChild(tBody.lastChild);
      }
      var ce = x => document.createElement(x);
      bodyLines.forEach(function (body, i) {
        var colors = tooltip.labelColors[i];
        var span = ce('span');
        span.style = ('background:' + colors.backgroundColor +
          '; border-color:' + colors.borderColor);
        var tableTr = ce('tr');
        var tableTd = ce('td');
        var tableText = document.createTextNode(body);
        tableTr.appendChild(tableTd);
        tableTd.appendChild(span);
        tableTd.appendChild(tableText);
        tBody.appendChild(tableTr);
      });
    }
    var positionX = this._chart.canvas.offsetLeft + tooltip.caretX;
    var positionY = this._chart.canvas.offsetTop + tooltip.caretY;
    var parentWidth = this.$.chartTarget.clientWidth;
    if (positionX + 100 > parentWidth) {
      positionX = parentWidth - 100;
    } else if (positionX < 100) {
      positionX = 100;
    }
    // Display, position, and set styles for font
    tooltipEl.style.opacity = 1;
    tooltipEl.style.top = positionY + 'px';
    tooltipEl.style.left = positionX + 'px';
    tooltipEl.style.padding = tooltip.yPadding + 'px ' + tooltip.xPadding + 'px';
  }
  _chartGetIntersection(chart, e, options) {
    var getRange = {
      x: (a, b) => Math.abs(a.x - b.x),
      y: (a, b) => Math.abs(a.y - b.y),
      xy: (a, b) => Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2),
    };
    var getRangeMax = {
      x: r => r,
      y: r => r,
      xy: r => r * r,
    };
    var position;
    if (e.native) {
      position = {
        x: e.x,
        y: e.y
      };
    } else {
      position = Chart.helpers.getRelativePosition(e, chart);
    }
    var elements = [];
    var elementsRange = [];
    var datasets = chart.data.datasets;
    var meta;
    options.axis = options.axis || 'xy';
    var rangeFunc = getRange[options.axis];
    var rangeMaxFunc = getRangeMax[options.axis];

    for (var i = 0, ilen = datasets.length; i < ilen; ++i) {
      if (!chart.isDatasetVisible(i)) {
        continue;
      }

      meta = chart.getDatasetMeta(i);
      for (var j = 0, jlen = meta.data.length; j < jlen; ++j) {
        var element = meta.data[j];
        if (!element._view.skip) {
          var vm = element._view;
          var range = rangeFunc(vm, position);
          var oldRange = elementsRange[i];
          if (range < rangeMaxFunc(vm.radius + vm.hitRadius)) {
            if (oldRange === undefined || oldRange > range) {
              elementsRange[i] = range;
              elements[i] = element;
            }
          }
        }
      }
    }
    var ret = elements.filter(function (n) { return n !== undefined; });
    return ret;
  }
  drawChart() {
    var data = this.data.data;
    var ctx = this.$.chartCanvas;


    if ((!data.datasets || !data.datasets.length) && !this._chart) {
      return;
    }

    if (this._chart) {
      this._customTooltips({ opacity: 0 });
      this._chart.data = data;
      this._chart.update({ duration: 0 });
      this.resizeChart();
    } else {
      if (!data.datasets) {
        return;
      }
      if (!Chart.Interaction.modes.neareach) {
        Chart.Interaction.modes.neareach = this._chartGetIntersection.bind(this);
      }
      // chartTarget.style.height = targetHeight;
      // chartTarget.height = targetHeight;
      this._tooltipEl = this.$.chartTooltip;
      this._customTooltips({ opacity: 0 });
      var options = {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          xAxes: [{
          }]
        },
        animation: {
          duration: 0,
        },
        hover: {
          animationDuration: 0,
        },
        responsiveAnimationDuration: 0,
        tooltips: {
          enabled: false,
          custom: this._customTooltips.bind(this),
        },
        legend: {
          display: false,
        },
      };
      options = Chart.helpers.merge(options, this.data.options);
      // options.scales = options.scales || {};
      // options.scales.xAxes = options.scales.xAxes || [];
      // options.scales.xAxes[0] = options.scales.xAxes[0] || {};
      // options.scales.xAxes[0].time = options.scales.xAxes[0].time || {};
      // options.scales.xAxes[0].time.displayFormats = {
      //   day: 'MMM d',
      //   hour: 'HH:mm',
      //   minute: 'HH:mm'
      // };
      if (this.data.type === 'timeline') {
        this._isTimeline = true;
      }
      this.$.chartTarget.style.height = '200px';
      this.$.chartTarget.height = '200px';
      this._chart = new Chart(ctx, {
        type: this.data.type,
        data: this.data.data,
        options: options
      });
      // Async resize after dom update
      setTimeout(this.resizeChart.bind(this), 1);
    }
  }
  resizeChart() {
    if (!this._chart) return;
    var options = this.data;
    var data = options.data;

    var chartTarget = this.$.chartTarget;

    if (this._isTimeline) {
      if (data.datasets.length === 0) {
        chartTarget.style.height = '0px';
        chartTarget.height = '0px';
        this._chart.resize();
      } else {
        var axis = this._chart.boxes.filter(x => x.position === 'bottom')[0];
        if (axis && axis.height > 0) {
          this._axisHeight = axis.height;
        }
        if (!this._axisHeight) {
          chartTarget.style.height = '100px';
          chartTarget.height = '100px';
          this._chart.resize();
          axis = this._chart.boxes.filter(x => x.position === 'bottom')[0];
          if (axis && axis.height > 0) {
            this._axisHeight = axis.height;
          }
        }
        if (this._axisHeight) {
          var cnt = data.datasets.length;
          var targetHeight = ((30 * cnt) + this._axisHeight) + 'px';
          if (chartTarget.style.height !== targetHeight) {
            chartTarget.style.height = targetHeight;
            chartTarget.height = targetHeight;
          }
          this._chart.resize();
        }
      }
    } else {
      this._chart.resize();
    }
  }
}
customElements.define(HaChartBase.is, HaChartBase);
</script>
