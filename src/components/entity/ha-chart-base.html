<link rel='import' href='../../../bower_components/polymer/polymer-element.html'>

<dom-module id="ha-chart-base">
  <template>
    <style>
      canvas{
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
      }
      #chartTooltip {
        opacity: 1;
        position: absolute;
        background: rgba(0, 0, 0, .7);
        color: white;
        border-radius: 3px;
        -webkit-transition: all .1s ease;
        transition: all .1s ease;
        pointer-events: none;
        -webkit-transform: translate(-50%, 0);
        transform: translate(-50%, 0);
      }
      .chartjs-tooltip-key {
        display: inline-block;
        width: 10px;
        height: 10px;
        margin-right: 10px;
      }
    </style>
    <div id="chartTarget" style="position: relative; height:200px; width:100%">
      <canvas id="chartCanvas"></canvas>
      <div id="chartTooltip">
        <table></table>
      </div>
    </div>
  </template>
</dom-module>
<script src="../../../bower_components/moment/moment.js"></script>
<script src="../../../bower_components/chart.js/dist/Chart.js"></script>
<script src="../../../bower_components/chartjs-chart-timeline/timeline.js"></script>
<!--script src="../../../../chartjs-chart-timeline/timeline.js"></script-->
<script>
/* global Chart moment */// eslint-disable-line no-unused-vars
class HaChartBase extends
  Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
  get chart() {
    return this._chart;
  }
  static get is() { return 'ha-chart-base'; }
  static get properties() {
    return {
      publish: {
        type: Boolean,
        observer: 'onPropsChange'
      },
      data: {
        type: Object,
        observer: 'onPropsChange'
      },
      selectedElement: {
        type: Object,
        readOnly: true,
        notify: true,
      },
      connected: {
        type: Object,
        readOnly: false,
        observer: 'onPropsChange'
      },
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.connected = true;
    this.addEventListener('iron-resize', () => {
      setTimeout(this.resizeChart.bind(this), 1);
    });
  }
  onPropsChange() {
    if (!this.connected || !this.publish || !this.data || !this.data.data) {
      return;
    }
    this.drawChart();
  }

  _customTooltips(tooltip) {
    // Tooltip Element
    var tooltipEl = this._tooltipEl;
    // console.log(tooltip);
    // Hide if no tooltip
    if (tooltip.opacity === 0) {
      tooltipEl.style.opacity = 0;
      return;
    }
    // Set caret Position
    tooltipEl.classList.remove('above', 'below', 'no-transform');
    if (tooltip.yAlign) {
      tooltipEl.classList.add(tooltip.yAlign);
    } else {
      tooltipEl.classList.add('no-transform');
    }
    function getBody(bodyItem) {
      return bodyItem.lines;
    }
    // Set Text
    if (tooltip.body) {
      var titleLines = tooltip.title || [];
      var bodyLines = tooltip.body.map(getBody);
      var innerHtml = '<thead>';
      titleLines.forEach(function (title) {
        innerHtml += '<tr><th>' + title + '</th></tr>';
      });
      innerHtml += '</thead><tbody>';
      bodyLines.forEach(function (body, i) {
        var colors = tooltip.labelColors[i];
        var style = 'background:' + colors.backgroundColor;
        style += '; border-color:' + colors.borderColor;
        style += '; border-width: 2px';
        var span = '<span class="chartjs-tooltip-key" style="' + style + '"></span>';
        innerHtml += '<tr><td>' + span + body + '</td></tr>';
      });
      innerHtml += '</tbody>';
      var tableRoot = tooltipEl.querySelector('table');
      tableRoot.innerHTML = innerHtml;
    }
    var positionY = this._chart.canvas.offsetTop;
    var positionX = this._chart.canvas.offsetLeft;
    // Display, position, and set styles for font
    tooltipEl.style.opacity = 1;
    tooltipEl.style.left = positionX + tooltip.caretX + 'px';
    tooltipEl.style.top = positionY + tooltip.caretY + 'px';
    tooltipEl.style.fontFamily = tooltip._fontFamily;
    tooltipEl.style.fontSize = tooltip.fontSize;
    tooltipEl.style.fontStyle = tooltip._fontStyle;
    tooltipEl.style.padding = tooltip.yPadding + 'px ' + tooltip.xPadding + 'px';
  }
  drawChart() {
    var data = this.data.data;
    var ctx = this.$.chartCanvas;

    if (!Chart.Interaction.modes.neareach) {
      var me = this;
      Chart.Interaction.modes.neareach = function (chart, e, opt) {
        var position;
        if (e.native) {
          position = {
            x: e.x,
            y: e.y
          };
        } else {
          position = Chart.helpers.getRelativePosition(e, chart);
        }
        var elements = [];
        var elementsRange = [];
        var datasets = chart.data.datasets;
        var meta;
        var positionX = position.x;

        for (var i = 0, ilen = datasets.length; i < ilen; ++i) {
          if (!chart.isDatasetVisible(i)) {
            continue;
          }

          meta = chart.getDatasetMeta(i);
          for (var j = 0, jlen = meta.data.length; j < jlen; ++j) {
            var element = meta.data[j];
            if (!element._view.skip) {
              var datasetIndex = element._datasetIndex;
              var vm = element._view;
              var xRange = Math.abs(vm.x - positionX);
              var oldX = elementsRange[datasetIndex];
              if (xRange < vm.radius + vm.hitRadius && (
                oldX === undefined || oldX > xRange)) {
                elementsRange[datasetIndex] = xRange;
                elements[datasetIndex] = element;
              }
            }
          }
        }
        return elements.filter(function (n) { return n !== undefined; });
      };
    }

    if ((!data.datasets || !data.datasets.length) && !this._chart) {
      return;
    }

    if (this._chart) {
      this._customTooltips({ opacity: 0 });
      this._chart.data = data;
      this._chart.update({ duration: 0 });
      this.resizeChart();
    } else {
      if (!data.datasets) {
        return;
      }
      // chartTarget.style.height = targetHeight;
      // chartTarget.height = targetHeight;
      this._tooltipEl = this.$.chartTooltip;
      var options = {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 0,
        },
        hover: {
          animationDuration: 0,
        },
        responsiveAnimationDuration: 0,
        tooltips: {
          enabled: false,
          custom: this._customTooltips.bind(this),
        },
        legend: {
          display: false,
        },
      };
      options = Chart.helpers.configMerge(options, this.data.options);
      if (this.data.type === 'timeline') {
        this._isTimeline = true;
      }
      this._chart = new Chart(ctx, {
        type: this.data.type,
        data: this.data.data,
        options: options
      });
      this.resizeChart();
    }
  }
  resizeChart() {
    if (!this._chart) return;
    var options = this.data;
    var data = options.data;

    var chartTarget = this.$.chartTarget;

    if (this._isTimeline) {
      if (data.datasets.length === 0) {
        chartTarget.style.height = '0px';
        chartTarget.height = '0px';
        this._chart.resize();
      } else {
        var axis = this._chart.boxes.filter(x => x.position === 'bottom')[0];
        if (axis && axis.height > 0) {
          this._axisHeight = axis.height;
        }
        if (!this._axisHeight) {
          chartTarget.style.height = '100px';
          chartTarget.height = '100px';
          this._chart.resize();
          axis = this._chart.boxes.filter(x => x.position === 'bottom')[0];
          if (axis && axis.height > 0) {
            this._axisHeight = axis.height;
            this.resizeChart();
          }
        }
        if (this._axisHeight) {
          var cnt = data.datasets.length;
          var targetHeight = ((30 * cnt) + this._axisHeight) + 'px';
          if (chartTarget.style.height !== targetHeight) {
            chartTarget.style.height = targetHeight;
            chartTarget.height = targetHeight;
          }
          this._chart.resize();
        }
      }
    } else {
      this._chart.resize();
    }
  }
}
customElements.define(HaChartBase.is, HaChartBase);
</script>
