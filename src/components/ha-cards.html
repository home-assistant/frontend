<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/debounce.html">

<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">

<link rel="import" href="./ha-demo-badge.html">
<link rel="import" href="../cards/ha-badges-card.html">
<link rel="import" href="../cards/ha-card-chooser.html">

<link rel="import" href="../util/hass-util.html">

<dom-module id="ha-cards">
  <template>
    <style is="custom-style" include="iron-flex iron-flex-factors"></style>
    <style>
      :host {
        display: block;
        padding: 4px 4px;
        transform: translateZ(0);
      }

      .badges {
        font-size: 85%;
        text-align: center;
      }

      .cards {
        /* sidebar is 256px and collapes at 870px
          taking 4px container padding into account column
          width should be between 286px and 303px to
          not flicker between 2 and 3 columns around
          sidebar collapse
        */
        column-width: 295px;
        column-gap: 0;
        column-count: 4;
        max-width: 1800px;
        margin: auto;
      }

      .cards.cols-1 { max-width: 500px; }
      .cards.cols-2 { max-width: 883px; } /* 3 * 295px - 2px */
      .cards.cols-3 { max-width: 1177px; } /* 4 * 295px - 3px */

      ha-card-chooser {
        display: inline-block;
        break-inside: avoid-column;
        box-sizing: border-box;
        width: 100%;
        padding: 4px;
      }

      @media (max-width: 500px) {
        ha-card-chooser {
          padding: 4px 0;
        }
        :host {
          padding: 8px 0;
        }
      }
      @media (min-width: 1000px) {
        .columns {
          column-width: 330px; /* force wider columns on bigger screens */
        }
      }
    </style>

    <div id='main'>
      <template is='dom-if' if='[[view.badges]]'>
        <div class='badges'>
          <template is='dom-if' if='[[view.demo]]'>
            <ha-demo-badge></ha-demo-badge>
          </template>

          <ha-badges-card states='[[view.badges]]' hass='[[hass]]'></ha-badges-card>
        </div>
      </template>

      <div class$='[[computeClasses(view.cards)]]'>
        <template is='dom-repeat' items='[[view.cards]]' as='card'>
            <!-- <template is='dom-repeat' items='[[column]]' as='card'> -->
              <ha-card-chooser card-data='[[card]]'></ha-card-chooser>
            <!-- </template> -->
          </div>
        </template>
    </div>
  </template>

</dom-module>

<script>
{
  // mapping domain to size of the card.
  const DOMAINS_WITH_CARD = {
    camera: 4,
    history_graph: 4,
    media_player: 3,
    persistent_notification: 0,
    plant: 3,
    weather: 4,
  };

  // 4 types:
  // badges: 0 .. 10
  // before groups < 0
  // groups: X
  // rest: 100

  const PRIORITY = {
    // before groups < 0
    configurator: -20,
    persistent_notification: -15,

    // badges have priority >= 0
    updater: 0,
    sun: 1,
    device_tracker: 2,
    alarm_control_panel: 3,
    timer: 4,
    sensor: 5,
    binary_sensor: 6,
    mailbox: 7,
  };

  const getPriority = domain =>
    ((domain in PRIORITY) ? PRIORITY[domain] : 100);

  const sortPriority = (domainA, domainB) =>
    domainA.priority - domainB.priority;

  const entitySortBy = (entityA, entityB) => {
    const nameA = (entityA.attributes.friendly_name ||
                 entityA.entity_id).toLowerCase();
    const nameB = (entityB.attributes.friendly_name ||
                 entityB.entity_id).toLowerCase();

    if (nameA < nameB) {
      return -1;
    }
    if (nameA > nameB) {
      return 1;
    }
    return 0;
  };

  const iterateDomainSorted = (collection, func) => {
    Object.keys(collection)
      .map(key => collection[key])
      .sort(sortPriority)
      .forEach((domain) => {
        domain.states.sort(entitySortBy);
        func(domain);
      });
  };

  const computeDomain = window.hassUtil.computeDomain;

  class HaCards extends Polymer.Element {
    static get is() { return 'ha-cards'; }
    static get properties() {
      return {
        hass: Object,

        columns: {
          type: Number,
          value: 2,
        },

        states: Object,
        panelVisible: Boolean,

        viewVisible: {
          type: Boolean,
          value: false,
        },

        orderedGroupEntities: Array,

        view: Object,
      };
    }

    static get observers() {
      return [
        'updateView(states, panelVisible, viewVisible, orderedGroupEntities)',
      ];
    }

    updateView(
      states,
      panelVisible,
      viewVisible,
      orderedGroupEntities
    ) {
      if (!panelVisible || !viewVisible) {
        if (this.$.main.parentNode) {
          this.$.main._parentNode = this.$.main.parentNode;
          this.$.main.parentNode.removeChild(this.$.main);
        }
        return;
      } else if (!this.$.main.parentNode && this.$.main._parentNode) {
        this.$.main._parentNode.appendChild(this.$.main);
      }
      this._debouncer = Polymer.Debouncer.debounce(
        this._debouncer,
        Polymer.Async.timeOut.after(10),
        () => {
          // Things might have changed since it got scheduled.
          if (this.panelVisible && this.viewVisible) {
            this.view = this.computeCards(states, orderedGroupEntities);
          }
        }
      );
    }

    emptyView() {
      return {
        demo: false,
        badges: [],
        cards: [],
      };
    }

    computeClasses(cards) {
      if (cards.length < 4) return `cards cols-${cards.length}`;
      return 'cards';
    }

    computeCards(states, orderedGroupEntities) {
      const hass = this.hass;

      const view = this.emptyView();

      function addEntitiesCard(name, entities, groupEntity) {
        if (entities.length === 0) return;

        const owncard = [];
        const other = [];


        entities.forEach((entity) => {
          const domain = computeDomain(entity);

          if (domain in DOMAINS_WITH_CARD) {
            owncard.push(entity);
          } else {
            other.push(entity);
          }
        });

        if (other.length > 0) {
          view.cards.push({
            hass: hass,
            cardType: 'entities',
            states: other,
            groupEntity: groupEntity || false,
          });
        }

        owncard.forEach((entity) => {
          view.cards.push({
            hass: hass,
            cardType: computeDomain(entity),
            stateObj: entity,
          });
        });
      }

      const splitted = window.HAWS.splitByGroups(states);
      if (orderedGroupEntities) {
        splitted.groups.sort((gr1, gr2) => orderedGroupEntities[gr1.entity_id] -
          orderedGroupEntities[gr2.entity_id]);
      } else {
        splitted.groups.sort((gr1, gr2) => gr1.attributes.order - gr2.attributes.order);
      }

      const badgesColl = {};
      const beforeGroupColl = {};
      const afterGroupedColl = {};

      Object.keys(splitted.ungrouped).forEach((key) => {
        const state = splitted.ungrouped[key];
        const domain = computeDomain(state);

        if (domain === 'a') {
          view.demo = true;
          return;
        }

        const priority = getPriority(domain);
        let coll;

        if (priority < 0) {
          coll = beforeGroupColl;
        } else if (priority < 10) {
          coll = badgesColl;
        } else {
          coll = afterGroupedColl;
        }

        if (!(domain in coll)) {
          coll[domain] = {
            domain: domain,
            priority: priority,
            states: [],
          };
        }

        coll[domain].states.push(state);
      });

      if (orderedGroupEntities) {
        Object.keys(badgesColl)
          .map(key => badgesColl[key])
          .forEach((domain) => {
            view.badges.push(...domain.states);
          });

        view.badges.sort((e1, e2) => orderedGroupEntities[e1.entity_id] -
          orderedGroupEntities[e2.entity_id]);
      } else {
        iterateDomainSorted(badgesColl, (domain) => {
          view.badges.push(...domain.states);
        });
      }

      iterateDomainSorted(beforeGroupColl, (domain) => {
        addEntitiesCard(domain.domain, domain.states);
      });

      splitted.groups.forEach((groupState) => {
        const entities = window.HAWS.getGroupEntities(states, groupState);
        addEntitiesCard(
          groupState.entity_id,
          Object.keys(entities).map(key => entities[key]),
          groupState
        );
      });

      iterateDomainSorted(afterGroupedColl, (domain) => {
        addEntitiesCard(domain.domain, domain.states);
      });

      return view;
    }
  }
  customElements.define(HaCards.is, HaCards);
}
</script>
