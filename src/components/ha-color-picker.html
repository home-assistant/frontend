<link rel='import' href='../../bower_components/polymer/polymer-element.html'>

<link rel='import' href='../../src/util/hass-mixins.html'>

<dom-module id='ha-color-picker'>
  <template>
    <style>
      canvas {
        cursor: crosshair;
        width: 100%;
        max-width: 330px;
      }
    </style>

    <canvas id='canvas'></canvas>
  </template>
</dom-module>

<script>
/**
 * Color-picker custom element
 * Originally created by bbrewer97202 (Ben Brewer). MIT Licensed.
 * https://github.com/bbrewer97202/color-picker-element
 *
 * Adapted to work with Polymer.
 */
class HaColorPicker extends window.hassMixins.EventsMixin(Polymer.Element) {
  static get is() { return 'ha-color-picker'; }

  static get properties() {
    return {
      color: {
        type: Object,
      },

      width: {
        type: Number,
        value: 500,
      },

      height: {
        type: Number,
        value: 500,
      },

      radius: {
        type: Number,
        value: 250,
      },

      borderWidth: {
        type: Number,
        value: 4,
      },

      borderColor: {
        type: String,
        value: 'white',
      },
    };
  }

  ready() {
    super.ready();
    this.addEventListener('mousedown', ev => this.onMouseDown(ev));
    this.addEventListener('touchstart', ev => this.onTouchStart(ev));
    this.setColor = this.setColor.bind(this);
    this.mouseMoveIsThrottled = true;
    this.canvas = this.$.canvas;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.context = this.canvas.getContext('2d');
    this.drawGradient();
  }

  // converts browser coordinates to canvas canvas coordinates
  // takes stretching/resizing of canvas into account
  // returns {x: X, y: Y} object
  convertToCanvasCoordinates(ev) {
    var rect = this.canvas.getBoundingClientRect();
    var elementX = ev.clientX - rect.left;
    var canvasX = (this.width / rect.width) * elementX;
    var elementY = ev.clientY - rect.top;
    var canvasY = (this.height / rect.height) * elementY;
    return { x: canvasX, y: canvasY };
  }

  onMouseDown(ev) {
    const cc = this.convertToCanvasCoordinates(ev);
    // return if we're not on the wheel
    if (!this.inWheel(cc.x, cc.y)) {
      return;
    }
    // a mousedown in wheel is always a color select action
    this.onColorSelect(cc.x, cc.y);
    // allow dragging
    this.addEventListener('mousemove', this.onMouseMove);
    this.addEventListener('mouseup', this.onMouseUp);
  }

  onMouseUp() {
    this.removeEventListener('mousemove', this.onMouseMove);
  }

  onMouseMove(ev) {
    if (!this.mouseMoveIsThrottled) {
      return;
    }
    this.mouseMoveIsThrottled = false;
    this.processColorSelect(ev);
    setTimeout(() => { this.mouseMoveIsThrottled = true; }, 50);
  }

  onTouchStart(ev) {
    // return if we're not on the wheel
    const cc = this.convertToCanvasCoordinates(ev.changedTouches[0]);
    if (!this.inWheel(cc.x, cc.y)) {
      return;
    }
    // if tap is on marker, go dragging
    if (false) {
      ev.preventDefault();
      this.onMarkerDrag(ev);
      this.addEventListener('touchmove', this.onMarkerDrag);
      return
    }
    // don't fire color selection immediately,
    // wait for touchend and invalidate when we scroll
    this.tapBecameDrag = false;
    this.addEventListener('touchend', this.onTap);
    this.addEventListener('touchmove', () => { this.tapBecameDrag = true; });


    // else only do lisen for touchend
    //this.onTouchMove(ev);
  }

  onTap(ev) {
    if (this.tapBecameDrag) {
      return
    }
    ev.preventDefault();
    const cc = this.convertToCanvasCoordinates(ev.changedTouches[0]);
    this.onColorSelect(cc.x, cc.y);
  }

  onTouchEnd() {
    this.removeEventListener('touchmove', this.onTouchMove);
  }

  onTouchMove(ev) {
    if (!this.mouseMoveIsThrottled) {
      return;
    }
    this.mouseMoveIsThrottled = false;
    this.processColorSelect(ev.touches[0]);
    setTimeout(() => { this.mouseMoveIsThrottled = true; }, 100);
  }

  processColorSelect(ev) {
    var rect = this.canvas.getBoundingClientRect();

    // adjust for a resized canvas:
    var elementX = ev.clientX - rect.left;
    var canvasX = (this.width / rect.width) * elementX;
    var elementY = ev.clientY - rect.top;
    var canvasY = (this.height / rect.height) * elementY;

    this.onColorSelect(canvasX, canvasY);
  }

  onColorSelect(x, y) {
    var color = this.getColor(x, y);
    console.log(color);
    this.setColor(color);
  }

  setColor(rgb) {
    this.color = rgb;
    this.fire('colorselected', { rgb: this.color });
  }

  getAngle(dX, dY) {
    var radians = Math.atan2(-dY, -dX); // radians from the left edge, clockwise = positive
    var degrees = Math.round((radians / Math.PI) * 180) + 180; // degrees, clockwise from right
    return degrees;
  }

  inWheel(x, y) {
    var d = this.deltaFromCenter(x, y);
    return this.getDistance(d.x, d.y) <= 1;
  }

  // return delta coordinates from center of wheel
  deltaFromCenter(x, y) {
    var cX = this.width / 2;
    var cY = this.height / 2;
    var dX = x - cX; // deltaX
    var dY = y - cY; // deltaY
    return { x: dX, y: dY };
  }

  // returns distance from wheel center, 0 = center, 1 = edge, >1 = outside
  getDistance(dX, dY) {
    return Math.sqrt((dX * dX) + (dY * dY)) / this.radius;
  }

  // x and y are canvas coordinates
  getColor(x, y) {
    var delta = this.deltaFromCenter(x, y);
    var hue = this.getAngle(delta.x, delta.y); // degrees, clockwise from right
    var relativeDistance = this.getDistance(delta.x, delta.y); // edge of radius = 1
    var sat = Math.min(relativeDistance, 1); // Distance from center
    return this.HSVtoRGB(hue, sat, 1);
  }


  drawGradient() {
    var context = this.context;
    var x = this.width / 2;
    var y = this.height / 2;
    var radius = this.radius;
    var counterClockwise = false;
    var borderWidth = this.borderWidth;
    var borderColor = this.borderColor;

    function drawCircle() {
      for (var angle = 0; angle <= 360; angle += 1) {
        var startAngle = (angle - 2) * (Math.PI / 180);
        var endAngle = angle * (Math.PI / 180);
        context.beginPath();
        context.moveTo(x, y);
        context.arc(x, y, radius, startAngle, endAngle, counterClockwise);
        context.closePath();
        var gradient = context.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0.1, 'hsl(' + angle + ', 100%, 100%)');
        gradient.addColorStop(0.55, 'hsl(' + angle + ', 100%, 80%)');
        gradient.addColorStop(0.95, 'hsl(' + angle + ', 100%, 51%)');
        context.fillStyle = gradient;
        context.fill();
      }
    }

    function drawShadow() {
      context.save();
      context.beginPath();
      context.arc(x, y, radius, 0, 2 * Math.PI, false);
      context.shadowOffsetX = 3;
      context.shadowOffsetY = 3;
      context.shadowBlur = 14;
      context.shadowColor = 'grey';
      context.fillStyle = 'white';
      context.fill();
      context.restore();
    }

    function drawBorder() {
      context.beginPath();
      context.arc(x, y, radius, 0, 2 * Math.PI, false);
      context.lineWidth = borderWidth;
      context.strokeStyle = borderColor;
      context.stroke();
    }
    drawShadow();
    drawCircle();
    drawBorder();
  }

  /**
  * modified from:
  * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
  * this takes h = hue (0-360), s = saturation (0-1), v = value (0-1)
  */

  /* eslint-disable one-var, no-mixed-operators, one-var-declaration-per-line */
  HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    // if (arguments.length === 1) {
    //   s = h.s; v = h.v; h = h.h;
    // }
    h = h / 360;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    /* eslint-disable default-case, no-sequences, no-unused-expressions */
    switch (i % 6) {
      case 0: r = v, g = t, b = p; break;
      case 1: r = q, g = v, b = p; break;
      case 2: r = p, g = v, b = t; break;
      case 3: r = p, g = q, b = v; break;
      case 4: r = t, g = p, b = v; break;
      case 5: r = v, g = p, b = q; break;
    }
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }
}
customElements.define(HaColorPicker.is, HaColorPicker);
</script>
