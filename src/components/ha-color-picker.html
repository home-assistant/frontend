<link rel='import' href='../../bower_components/polymer/polymer-element.html'>
<link rel="import" href="../../bower_components/polymer/lib/utils/debounce.html">

<link rel='import' href='../../src/util/hass-mixins.html'>

<dom-module id='ha-color-picker'>
  <template>
    <style>
      #canvas {
        position: relative;
        width: 100%;
        max-width: 330px;
        user-select: none;
        overflow: visible;
      }
      #canvas > * {
        display: block;
        user-select: none;
      }
      #interactionLayer {
        color: white;
        position: absolute;
        cursor: crosshair;
        width: 100%;
        height: 100%;
        overflow: visible;
      }
      #backgroundLayer {
        width: 100%;
        overflow: visible;
      }

      #wheel {
        stroke: white;
        stroke-width: 3;
        box-shadow: 4px 4px 10px darkgrey;
      }

      #marker {
        fill: currentColor;
        stroke: white;
        stroke-width: 4;
        filter: url(#marker-shadow)
      }
      .dragging #marker {
      }

      #colorTooltip {
        display: none;
        fill: currentColor;
        stroke: white;
        stroke-width: 4;
      }

      .touch.dragging #colorTooltip {
        display: inherit;
      }

    </style>
    <div id='canvas'>
      <svg id='interactionLayer'>
        <defs>
          <filter id="marker-shadow" x="-50%" y="-50%" width="200%" height="200%" filterUnits="objectBoundingBox">
             <feOffset result="offOut" in="SourceAlpha" dx="2" dy="2" />
             <feGaussianBlur result="blurOut" in="offOut" stdDeviation="2" />
             <feComponentTransfer in="blurOut" result="alphaOut">
               <feFuncA type="linear" slope="0.3" />
             </feComponentTransfer>
             <feBlend in="SourceGraphic" in2="alphaOut" mode="normal" />
          </filter>
        </defs>
      </svg>
      <canvas id='backgroundLayer'></canvas>
      <!-- this is a hidden element from which we take css styles to apply to canvas drawing -->
      <div id='wheel' style='display: none'></div>
    </div>
  </template>
</dom-module>

<script>
/**
 * Color-picker custom element
 */
class HaColorPicker extends window.hassMixins.EventsMixin(Polymer.Element) {
  static get is() { return 'ha-color-picker'; }

  static get properties() {
    return {
      hsvColor: {
        type: Object,
      },

      rgbColor: {
        type: Object,
      },

      // use these properties to update the state via attributes
      desiredHsvColor: {
        type: Object,
        observer: 'applyHsvColor'
      },

      desiredRgbColor: {
        type: Object,
        observer: 'applyRgbColor'
      },


      // width, height and radius apply to the coordinates of
      // of the canvas.
      // border width are relative to these numbers
      // the onscreen displayed size should be controlled with css
      // and should be the same or smaller
      width: {
        type: Number,
        value: 500,
      },

      height: {
        type: Number,
        value: 500,
      },

      radius: {
        type: Number,
        value: 225,
      },

      // the amount segments for the hue
      // 0 = continious gradient
      // other than 0 gives 'pie-pieces'
      hueSegments: {
        type: Number,
        value: 0,
      },

      // the amount segments for the hue
      // 0 = continious gradient
      // 1 = only fully saturated
      // > 1 = segments from white to fully saturated
      saturationSegments: {
        type: Number,
        value: 0,
      },

      // set to true to make the segments purely esthetical
      // this allows selection off all collors, also
      // interpolated between the segments
      ignoreSegments: {
        type: Boolean,
        value: false
      },

      // throttle te amount of 'colorselected' events fired
      // value is timeout in milliseconds
      throttle: {
        type: Number,
        value: 500,
      }
    };
  }

  ready() {
    super.ready();
    this.applyRgbColor = this.applyRgbColor.bind(this);
    this.setupLayers();
    this.drawColorWheel();
    this.drawMarker();

    this.interactionLayer.addEventListener('mousedown', ev => this.onMouseDown(ev));
    this.interactionLayer.addEventListener('touchstart', ev => this.onTouchStart(ev));
  }

  // converts browser coordinates to canvas canvas coordinates
  // origin is wheel center
  // returns {x: X, y: Y} object
  convertToCanvasCoordinates(clientX, clientY) {
    var svgPoint = this.interactionLayer.createSVGPoint();
    svgPoint.x = clientX;
    svgPoint.y = clientY;
    var cc = svgPoint.matrixTransform(this.interactionLayer.getScreenCTM().inverse());
    return { x: cc.x, y: cc.y };
  }

  // Mouse events

  onMouseDown(ev) {
    const cc = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);
    // return if we're not on the wheel
    if (!this.isInWheel(cc.x, cc.y)) {
      return;
    }
    // a mousedown in wheel is always a color select action
    this.onMouseSelect(ev);
    // allow dragging
    this.canvas.classList.add('mouse', 'dragging');
    this.addEventListener('mousemove', this.onMouseSelect);
    this.addEventListener('mouseup', this.onMouseUp);
  }

  onMouseUp() {
    this.canvas.classList.remove('mouse', 'dragging');
    this.removeEventListener('mousemove', this.onMouseSelect);
  }

  onMouseSelect(ev) {
    requestAnimationFrame(() => this.processUserSelect(ev));
  }

  // Touch events

  onTouchStart(ev) {
    var touch = ev.changedTouches[0];
    const cc = this.convertToCanvasCoordinates(touch.clientX, touch.clientY);
    // return if we're not on the wheel
    if (!this.isInWheel(cc.x, cc.y)) {
      return;
    }
    if (ev.target === this.marker) { // drag marker
      ev.preventDefault();
      this.canvas.classList.add('touch', 'dragging');
      this.addEventListener('touchmove', this.onTouchSelect);
      this.addEventListener('touchend', this.onTouchEnd);
      return;
    }
    // don't fire color selection immediately,
    // wait for touchend and invalidate when we scroll
    this.tapBecameScroll = false;
    this.addEventListener('touchend', this.onTap);
    this.addEventListener('touchmove', () => { this.tapBecameScroll = true; }, { passive: true });
  }

  onTap(ev) {
    if (this.tapBecameScroll) {
      return;
    }
    ev.preventDefault();
    this.onTouchSelect(ev);
  }

  onTouchEnd() {
    this.canvas.classList.remove('touch', 'dragging');
    this.removeEventListener('touchmove', this.onTouchSelect);
  }

  onTouchSelect(ev) {
    requestAnimationFrame(() => this.processUserSelect(ev.changedTouches[0]));
  }

  // Process user input to color
  processUserSelect(ev) {
    var canvasXY = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);
    var hsv = this.getColor(canvasXY.x, canvasXY.y);
    this.onColorSelect(hsv);
  }

  // apply color to marker position and canvas
  onColorSelect(hsv) {
    this.setMarkerOnColor(hsv); // marker always follows mounse 'raw' hsv value (= mouse position)
    if (!this.ignoreSegments) { // apply segments if needed
      hsv = this.applySegmentFilter(hsv);
    }
    // always apply the new color to the interface / canvas
    this.applyColorToCanvas(hsv);
    // throttling is applied to updating the exposed colors (properties)
    // and firing of events
    if (this.colorSelectIsThrottled) {
      // make sure we apply the last selected color
      // eventually after throttle limit has passed
      clearTimeout(this.ensureFinalSelect);
      this.ensureFinalSelect = setTimeout(() => {
        this.fireColorSelected(hsv); // do it for the final time
      }, this.throttle);
      return;
    }
    this.fireColorSelected(hsv); // do it
    this.colorSelectIsThrottled = true;
    setTimeout(() => {
      this.colorSelectIsThrottled = false;
    }, this.throttle);
  }

  fireColorSelected(hsv) {
    this.hsvColor = hsv;
    this.rgbColor = this.HSVtoRGB(this.hsvColor);
    this.fire('colorselected', { rgb: this.rgbColor, hsv: this.hsvColor });
  }


  // set marker position to the given color
  setMarkerOnColor(hsv) {
    var dist = hsv.s * this.radius;
    var theta = ((hsv.h - 180) / 180) * Math.PI;
    var markerdX = -dist * Math.cos(theta);
    var markerdY = -dist * Math.sin(theta);
    var translateString = `translate(${markerdX},${markerdY})`;
    this.marker.setAttribute('transform', translateString);
    this.tooltip.setAttribute('transform', translateString);
  }

  // apply given color to interface elements
  applyColorToCanvas(hsv) {
    // we're not really converting hsv to hsl here, but we keep it cheap
    // setting the color on the interactionLayer, the svg elements can inherit
    this.interactionLayer.style.color = `hsl(${hsv.h}, ${hsv.v * 100}%, ${100 - (hsv.s * 50)}%)`;
  }

  /*
  * applyRgbColor and applyHsvColor are used for external updates
  * (to prevent observer loops on this.hsvColor and this.rgbColor)
  */

  applyRgbColor(rgb) {
    // do nothing is we already have the same color
    if (this.rgbColor &&
        this.rgbColor.r === rgb.r &&
        this.rgbColor.g === rgb.g &&
        this.rgbColor.b === rgb.b) {
      return;
    }
    var hsv = this.RGBtoHSV(rgb);
    this.applyHsvColor(hsv); // marker is always set on 'raw' hsv position
  }

  applyHsvColor(hsv) {
    // do nothing is we already have the same color
    if (this.hsvColor &&
        this.hsvColor.h === hsv.h &&
        this.hsvColor.s === hsv.s &&
        this.hsvColor.v === hsv.v) {
      return;
    }
    this.setMarkerOnColor(hsv); // marker is always set on 'raw' hsv position
    if (!this.ignoreSegments) { // apply segments if needed
      hsv = this.applySegmentFilter(hsv);
    }
    this.hsvColor = hsv;
    this.rgbColor = this.HSVtoRGB(hsv);
    // always apply the new color to the interface / canvas
    this.applyColorToCanvas(hsv);
  }


  /*
  * input processing helpers
  */

  getAngle(dX, dY) {
    var theta = Math.atan2(-dY, -dX); // radians from the left edge, clockwise = positive
    var angle = ((theta / Math.PI) * 180) + 180; // degrees, clockwise from right
    return angle;
  }

  isInWheel(x, y) {
    return this.getDistance(x, y) <= 1;
  }

  // returns distance from wheel center, 0 = center, 1 = edge, >1 = outside
  getDistance(dX, dY) {
    return Math.sqrt((dX * dX) + (dY * dY)) / this.radius;
  }

  getColor(x, y) {
    var hue = this.getAngle(x, y); // degrees, clockwise from right
    var relativeDistance = this.getDistance(x, y); // edge of radius = 1
    var sat = Math.min(relativeDistance, 1); // Distance from center
    return { h: hue, s: sat, v: 1 };
  }

  applySegmentFilter(hsv) {
    // apply hue segment steps
    if (this.hueSegments) {
      const angleStep = 360 / this.hueSegments;
      const halfAngleStep = angleStep / 2;
      hsv.h -= halfAngleStep; // take the 'centered segemnts' into account
      if (hsv.h < 0) { hsv.h += 360; } // don't end up below 0
      const rest = hsv.h % angleStep;
      hsv.h -= rest - angleStep;
    }

    // apply saturation segment steps
    if (this.saturationSegments) {
      if (this.saturationSegments === 1) {
        hsv.s = 1;
      } else {
        var segmentSize = 1 / this.saturationSegments;
        var saturationStep = 1 / (this.saturationSegments - 1);
        var calculatedSat = Math.floor(hsv.s / segmentSize) * saturationStep;
        hsv.s = Math.min(calculatedSat, 1);
      }
    }
    return hsv;
  }

  // the canvas and svg elements can be scaled
  // so they have a seperate coordinate system
  setupLayers() {
    this.canvas = this.$.canvas;
    this.backgroundLayer = this.$.backgroundLayer;
    this.interactionLayer = this.$.interactionLayer;

    // coordinate origin position (center of the wheel)
    this.originX = this.width / 2;
    this.originY = this.originX;

    // synchronise with/height coordinates
    this.backgroundLayer.width = this.width;
    this.backgroundLayer.height = this.height;
    this.interactionLayer.setAttribute('viewBox', `${-this.originX} ${-this.originY} ${this.width} ${this.height}`);
  }

  drawColorWheel() {
    let shadowColor;
    let shadowOffsetX;
    let shadowOffsetY;
    let shadowBlur;
    const context = this.backgroundLayer.getContext('2d');
    // postioning and sizing
    const cX = this.originX;
    const cY = this.originY;
    const radius = this.radius;
    const counterClockwise = false;
    // styling of the wheel
    const wheelStyle = computeStyleFrom(this.$.wheel);
    const borderWidth = parseInt(wheelStyle.borderWidth, 10);
    const borderColor = wheelStyle.borderColor;
    // extract shadow properties from computed CCS style
    // both Webkit and Firefox return computed box-shadow as: "rgb(15, 15, 15) 10px 5px 5px 0px"
    if (wheelStyle.shadow !== 'none') {
      const pattern = /^(.*?\))\s(.*)/g;
      const match = pattern.exec(wheelStyle.shadow);
      const offsets = match[2].split(' ');
      shadowColor = match[1];
      shadowOffsetX = parseInt(offsets[0], 10);
      shadowOffsetY = parseInt(offsets[1], 10);
      shadowBlur = parseInt(offsets[2], 10) || 0;
    }
    const borderRadius = radius + (borderWidth / 2);
    const wheelRadius = radius;

    function drawCircle(hueSegments, saturationSegments) {
      hueSegments = hueSegments || 360; // reset 0 segments to 360
      const angleStep = 360 / hueSegments;
      const halfAngleStep = angleStep / 2; // center segments on color
      for (var angle = 0; angle <= 360; angle += angleStep) {
        var startAngle = ((angle - halfAngleStep)) * (Math.PI / 180);
        var endAngle = ((angle + halfAngleStep) + 1) * (Math.PI / 180);
        context.beginPath();
        context.moveTo(cX, cY);
        context.arc(cX, cY, wheelRadius, startAngle, endAngle, counterClockwise);
        context.closePath();
        // gradient
        var gradient = context.createRadialGradient(cX, cY, 0, cX, cY, wheelRadius);
        let lightness = 100;
        // first gradient stop
        gradient.addColorStop(0, `hsl(${angle}, 100%, ${lightness}%)`);
        if (saturationSegments > 0) {
          const ratioStep = 1 / saturationSegments;
          let ratio = 0;
          for (var stop = 1; stop < saturationSegments; stop += 1) {
            var prevLighness = lightness;
            ratio = stop * ratioStep;
            lightness = 100 - (50 * ratio);
            gradient.addColorStop(ratio, `hsl(${angle}, 100%, ${prevLighness}%)`);
            gradient.addColorStop(ratio, `hsl(${angle}, 100%, ${lightness}%)`);
          }
          gradient.addColorStop(ratio, `hsl(${angle}, 100%, 50%)`);
        }
        // last gradient stop
        gradient.addColorStop(1, `hsl(${angle}, 100%, 50%)`);

        context.fillStyle = gradient;
        context.fill();
      }
    }

    function drawShadow() {
      context.save();
      context.beginPath();
      context.arc(cX, cY, borderRadius, 0, 2 * Math.PI, false);
      context.shadowColor = shadowColor;
      context.shadowOffsetX = shadowOffsetX;
      context.shadowOffsetY = shadowOffsetY;
      context.shadowBlur = shadowBlur;
      context.fillStyle = 'white';
      context.fill();
      context.restore();
    }

    function drawBorder() {
      context.beginPath();
      context.arc(cX, cY, borderRadius, 0, 2 * Math.PI, false);
      context.lineWidth = borderWidth;
      context.strokeStyle = borderColor;
      context.stroke();
    }

    function computeStyleFrom(element) {
      var styleReference = window.getComputedStyle(element, null);
      // Get needed stuff from the dom and put it in the cache
      // P.S. Didn't test if canvas names are the same as css names.
      // If not you'll have to translate itgetPropertyValue('box-shadow')
      var elementStyle = {
        borderWidth: styleReference.getPropertyValue('stroke-width'),
        borderColor: styleReference.getPropertyValue('stroke'),
        shadow: styleReference.getPropertyValue('box-shadow')
      };

      // Remove the element from the dom again
      // parentElement.removeChild(shadowElement);

      return elementStyle;
    }

    if (wheelStyle.shadow !== 'none') {
      drawShadow();
    }
    drawCircle(this.hueSegments, this.saturationSegments);

    if (borderWidth > 0) {
      drawBorder();
    }
  }

  drawMarker() {
    const svgElement = this.interactionLayer;
    const markerradius = this.radius * 0.08;
    const tooltipradius = this.radius * 0.15;
    const TooltipOffsetY = -(tooltipradius * 2);
    const TooltipOffsetX = 0;

    svgElement.marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    svgElement.marker.setAttribute('id', 'marker');
    svgElement.marker.setAttribute('r', markerradius);
    this.marker = svgElement.marker;
    svgElement.appendChild(svgElement.marker);

    svgElement.tooltip = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    svgElement.tooltip.setAttribute('id', 'colorTooltip');
    svgElement.tooltip.setAttribute('r', tooltipradius);
    svgElement.tooltip.setAttribute('cx', TooltipOffsetX);
    svgElement.tooltip.setAttribute('cy', TooltipOffsetY);


    this.tooltip = svgElement.tooltip;
    svgElement.appendChild(svgElement.tooltip);
  }

  /**
  * modified from:
  * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
  * this takes h = hue (0-360), s = saturation (0-1), v = value (0-1)
  */

  /* eslint-disable one-var, no-mixed-operators, one-var-declaration-per-line */
  HSVtoRGB(hsv) {
    var r, g, b, i, f, p, q, t;
    var h = hsv.h, s = hsv.s, v = hsv.v;
    h /= 360;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    /* eslint-disable default-case, no-sequences, no-unused-expressions */
    switch (i % 6) {
      case 0: r = v, g = t, b = p; break;
      case 1: r = q, g = v, b = p; break;
      case 2: r = p, g = v, b = t; break;
      case 3: r = p, g = q, b = v; break;
      case 4: r = t, g = p, b = v; break;
      case 5: r = v, g = p, b = q; break;
    }
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }


  RGBtoHSV(rgb) {
    var r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h *= 60; // hue values 0-360
    }
    return {
      h: h,
      s: s,
      v: v
    };
  }
}
customElements.define(HaColorPicker.is, HaColorPicker);
</script>
