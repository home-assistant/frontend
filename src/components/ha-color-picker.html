<link rel='import' href='../../bower_components/polymer/polymer-element.html'>

<link rel='import' href='../../src/util/hass-mixins.html'>

<dom-module id='ha-color-picker'>
  <template>
    <style>
      #canvas {
        position: relative;
        width: 100%;
        max-width: 330px;
      }
      #canvas > * {
        display: block;
      }
      #interactionLayer {
        position: absolute;
        cursor: crosshair;
        width: 100%;
        height: 100%;
      }
      #wheel {
        width: 100%;
      }

      #marker {
        fill: white;
        stroke: white;
        stroke-width: 4;
        filter: url(#marker-shadow);
      }

    </style>
    <div id='canvas'>
      <svg id='interactionLayer'>
        <defs>
          <filter id="marker-shadow" x="-50%" y="-50%" width="200%" height="200%" filterUnits="objectBoundingBox">
            <feOffset in="SourceAlpha" dx="2" dy="2"/>
            <feGaussianBlur in="offset" stdDeviation="2"/>
            <feComponentTransfer>
              <feFuncA type="linear" slope="0.3"/>
            </feComponentTransfer>
            <feMerge>
              <feMergeNode/>
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
      </svg>
      <canvas id='wheel'></canvas>
    </div>
  </template>
</dom-module>

<script>
/**
 * Color-picker custom element
 * Originally created by bbrewer97202 (Ben Brewer). MIT Licensed.
 * https://github.com/bbrewer97202/color-picker-element
 *
 * Adapted to work with Polymer.
 */
class HaColorPicker extends window.hassMixins.EventsMixin(Polymer.Element) {
  static get is() { return 'ha-color-picker'; }

  static get properties() {
    return {
      color: {
        type: Object,
      },

      hsvColor: {
        type: Object,
        observer: 'setMarkerOnColor'
      },

      width: {
        type: Number,
        value: 500,
      },

      height: {
        type: Number,
        value: 500,
      },

      radius: {
        type: Number,
        value: 225,
      },

      borderWidth: {
        type: Number,
        value: 5,
      },

      borderColor: {
        type: String,
        value: 'white',
      },
    };
  }

  ready() {
    super.ready();
    this.setColor = this.setColor.bind(this);
    this.dragIsThrottled = true;
    this.setupLayers();
    this.drawColorWheel();
    this.drawMarker();

    this.interactionLayer.addEventListener('mousedown', ev => this.onMouseDown(ev));
    this.interactionLayer.addEventListener('touchstart', ev => this.onTouchStart(ev));
  }

  // converts browser coordinates to canvas canvas coordinates
  // origin is wheel center
  // returns {x: X, y: Y} object
  convertToCanvasCoordinates(clientX, clientY) {
    var svgPoint = this.interactionLayer.createSVGPoint();
    svgPoint.x = clientX;
    svgPoint.y = clientY;
    var cc = svgPoint.matrixTransform(this.interactionLayer.getScreenCTM().inverse());
    return { x: cc.x, y: cc.y };
  }

  onMouseDown(ev) {
    const cc = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);
    // return if we're not on the wheel
    if (!this.inWheel(cc.x, cc.y)) {
      return;
    }
    // a mousedown in wheel is always a color select action
    this.onColorSelect(cc.x, cc.y);
    // allow dragging
    this.addEventListener('mousemove', this.onMouseMove);
    this.addEventListener('mouseup', this.onMouseUp);
  }

  onMouseUp() {
    this.removeEventListener('mousemove', this.onMouseMove);
  }

  onMouseMove(ev) {
    if (!this.dragIsThrottled) {
      return;
    }
    this.dragIsThrottled = false;
    this.processColorSelect(ev);
    setTimeout(() => { this.dragIsThrottled = true; }, 15);
  }

  onTouchStart(ev) {
    var touch = ev.changedTouches[0];
    const cc = this.convertToCanvasCoordinates(touch.clientX, touch.clientY);
    // return if we're not on the wheel
    if (!this.inWheel(cc.x, cc.y)) {
      return;
    }
    if (ev.target === this.marker) { // drag marker
      ev.preventDefault();
      this.addEventListener('touchmove', this.onMarkerDrag);
      this.addEventListener('touchend', this.onDragEnd);
      return;
    }
    // don't fire color selection immediately,
    // wait for touchend and invalidate when we scroll
    this.tapBecameDrag = false;
    this.addEventListener('touchend', this.onTap);
    this.addEventListener('touchmove', () => { this.tapBecameDrag = true; }, { passive: true });
  }

  onTap(ev) {
    if (this.tapBecameDrag) {
      return;
    }
    ev.preventDefault();
    var touch = ev.changedTouches[0];
    const cc = this.convertToCanvasCoordinates(touch.clientX, touch.clientY);
    this.onColorSelect(cc.x, cc.y);
  }

  onDragEnd() {
    this.removeEventListener('touchmove', this.onMarkerDrag);
  }

  onMarkerDrag(ev) {
    if (!this.dragIsThrottled) {
      return;
    }
    this.dragIsThrottled = false;
    this.processColorSelect(ev.touches[0]);
    setTimeout(() => { this.dragIsThrottled = true; }, 20);
  }

  processColorSelect(ev) {
    var canvasXY = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);
    this.onColorSelect(canvasXY.x, canvasXY.y);
  }

  onColorSelect(x, y) {
    this.hsvColor = this.getColor(x, y);
    this.color = this.HSVtoRGB(this.hsvColor);
    this.fire('colorselected', { rgb: this.color });
  }

  setMarkerOnColor(hsv) {
    var dist = hsv.s * this.radius;
    var theta = ((hsv.h - 180) / 180) * Math.PI;
    var markerdX = -dist * Math.cos(theta);
    var markerdY = -dist * Math.sin(theta);
    // we're not really converitng hsv to hsl here, but we keep it cheap
    this.marker.style.fill = `hsl(${hsv.h}, ${hsv.v * 100}%, ${100 - (hsv.s * 50)}%)`;
    this.marker.setAttribute('transform', `translate(${markerdX},${markerdY})`);
  }

  setColor(rgb) {
    this.color = rgb;
    this.hsvColor = this.RGBtoHSV(rgb);
  }

  getAngle(dX, dY) {
    var theta = Math.atan2(-dY, -dX); // radians from the left edge, clockwise = positive
    var angle = ((theta / Math.PI) * 180) + 180; // degrees, clockwise from right
    return angle;
  }

  inWheel(x, y) {
    return this.getDistance(x, y) <= 1;
  }

  // returns distance from wheel center, 0 = center, 1 = edge, >1 = outside
  getDistance(dX, dY) {
    return Math.sqrt((dX * dX) + (dY * dY)) / this.radius;
  }

  getColor(x, y) {
    var hue = this.getAngle(x, y); // degrees, clockwise from right
    var relativeDistance = this.getDistance(x, y); // edge of radius = 1
    var sat = Math.min(relativeDistance, 1); // Distance from center
    return { h: hue, s: sat, v: 1 };
  }

  setupLayers() {
    this.canvas = this.$.canvas;
    this.backgroundLayer = this.$.wheel;
    this.interactionLayer = this.$.interactionLayer;

    this.originX = this.width / 2;
    this.originY = this.originX;

    this.backgroundLayer.width = this.width;
    this.backgroundLayer.height = this.height;

    this.interactionLayer.setAttribute('viewBox', `${-this.originX} ${-this.originY} ${this.width} ${this.height}`);
  }

  drawColorWheel() {
    const context = this.backgroundLayer.getContext('2d');
    const cX = this.originX;
    const cY = this.originY;
    const radius = this.radius;
    const counterClockwise = false;
    const borderWidth = this.borderWidth;
    const borderColor = this.borderColor;
    const borderRadius = radius + (borderWidth / 2);
    const wheelRadius = borderRadius - 1;

    function drawCircle() {
      for (var angle = 0; angle <= 360; angle += 1) {
        var startAngle = (angle - 2) * (Math.PI / 180);
        var endAngle = angle * (Math.PI / 180);
        context.beginPath();
        context.moveTo(cX, cY);
        context.arc(cX, cY, wheelRadius, startAngle, endAngle, counterClockwise);
        context.closePath();
        var gradient = context.createRadialGradient(cX, cY, 0, cX, cY, wheelRadius);
        gradient.addColorStop(0.1, 'hsl(' + angle + ', 100%, 100%)');
        gradient.addColorStop(0.95, 'hsl(' + angle + ', 100%, 50%)');
        context.fillStyle = gradient;
        context.fill();
      }
    }

    function drawShadow() {
      context.save();
      context.beginPath();
      context.arc(cX, cY, radius, 0, 2 * Math.PI, false);
      context.shadowOffsetX = 3;
      context.shadowOffsetY = 3;
      context.shadowBlur = 14;
      context.shadowColor = 'grey';
      context.fillStyle = 'white';
      context.fill();
      context.restore();
    }

    function drawBorder() {
      context.beginPath();
      context.arc(cX, cY, borderRadius, 0, 2 * Math.PI, false);
      context.lineWidth = borderWidth;
      context.strokeStyle = borderColor;
      context.stroke();
    }
    drawShadow();
    drawCircle();
    drawBorder();
  }

  drawMarker() {
    const svgElement = this.interactionLayer;
    const markerradius = this.radius * 0.07;

    svgElement.marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    svgElement.marker.setAttribute('id', 'marker');
    svgElement.marker.setAttribute('r', markerradius);
    this.marker = svgElement.marker;
    svgElement.appendChild(svgElement.marker);
  }

  /**
  * modified from:
  * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
  * this takes h = hue (0-360), s = saturation (0-1), v = value (0-1)
  */

  /* eslint-disable one-var, no-mixed-operators, one-var-declaration-per-line */
  HSVtoRGB(hsv) {
    var r, g, b, i, f, p, q, t;
    var h = hsv.h, s = hsv.s, v = hsv.v;
    h /= 360;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    /* eslint-disable default-case, no-sequences, no-unused-expressions */
    switch (i % 6) {
      case 0: r = v, g = t, b = p; break;
      case 1: r = q, g = v, b = p; break;
      case 2: r = p, g = v, b = t; break;
      case 3: r = p, g = q, b = v; break;
      case 4: r = t, g = p, b = v; break;
      case 5: r = v, g = p, b = q; break;
    }
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }


  RGBtoHSV(rgb) {
    var r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return {
      h: h,
      s: s,
      v: v
    };
  }
}
customElements.define(HaColorPicker.is, HaColorPicker);
</script>
