<link rel='import' href='../../bower_components/polymer/polymer-element.html'>

<link rel='import' href='../../src/util/hass-mixins.html'>

<dom-module id='ha-color-picker'>
  <template>
    <style>
      canvas {
        cursor: crosshair;
        width: 100%;
      }
    </style>

    <canvas id='canvas'></canvas>
  </template>
</dom-module>

<script>
/**
 * Color-picker custom element
 * Originally created by bbrewer97202 (Ben Brewer). MIT Licensed.
 * https://github.com/bbrewer97202/color-picker-element
 *
 * Adapted to work with Polymer.
 */
class HaColorPicker extends window.hassMixins.EventsMixin(Polymer.Element) {
  static get is() { return 'ha-color-picker'; }

  static get properties() {
    return {
      color: {
        type: Object,
      },

      width: {
        type: Number,
      },

      height: {
        type: Number,
      },
    };
  }

  ready() {
    super.ready();
    this.addEventListener('mousedown', ev => this.onMouseDown(ev));
    this.addEventListener('mouseup', ev => this.onMouseUp(ev));
    this.addEventListener('touchstart', ev => this.onTouchStart(ev));
    this.addEventListener('touchend', ev => this.onTouchEnd(ev));
    this.setColor = this.setColor.bind(this);
    this.mouseMoveIsThrottled = true;
    this.canvas = this.$.canvas;
    this.context = this.canvas.getContext('2d');
    this.drawGradient();
  }

  onMouseDown(ev) {
    this.onMouseMove(ev);
    this.addEventListener('mousemove', this.onMouseMove);
  }

  onMouseUp() {
    this.removeEventListener('mousemove', this.onMouseMove);
  }

  onTouchStart(ev) {
    this.onTouchMove(ev);
    this.addEventListener('touchmove', this.onTouchMove);
  }

  onTouchEnd() {
    this.removeEventListener('touchmove', this.onTouchMove);
  }

  onTouchMove(ev) {
    if (!this.mouseMoveIsThrottled) {
      return;
    }
    this.mouseMoveIsThrottled = false;
    this.processColorSelect(ev.touches[0]);
    setTimeout(() => { this.mouseMoveIsThrottled = true; }, 100);
  }

  onMouseMove(ev) {
    if (!this.mouseMoveIsThrottled) {
      return;
    }
    this.mouseMoveIsThrottled = false;
    this.processColorSelect(ev);
    setTimeout(() => { this.mouseMoveIsThrottled = true; }, 100);
  }

  processColorSelect(ev) {
    var rect = this.canvas.getBoundingClientRect();

    // boundary check because people can move off-canvas.
    if (ev.clientX < rect.left || ev.clientX >= rect.left + rect.width ||
        ev.clientY < rect.top || ev.clientY >= rect.top + rect.height) {
      return;
    }
    // adjust for a resized canvas:
    var elementX = ev.clientX - rect.left;
    var canvasX = (500 / rect.width) * elementX;
    var elementY = ev.clientY - rect.top;
    var canvasY = (500 / rect.height) * elementY;

    this.onColorSelect(canvasX, canvasY);
  }

  onColorSelect(x, y) {
    var color = this.getColor(x, y);
    console.log(color);
    this.setColor(color);
  }

  setColor(rgb) {
    this.color = rgb;
    this.fire('colorselected', { rgb: this.color });
  }

  getAngle(dX, dY) {
    var radians = Math.atan2(-dY, -dX); // radians from the left edge, clockwise = positive
    var degrees = Math.round((radians / Math.PI) * 180) + 180; // degrees, clockwise from right
    return degrees;
  }

  getDistance(dX, dY) {
    return Math.sqrt((dX * dX) + (dY * dY));
  }

  getColor(x, y) {
    var width = 500;
    var height = 500;
    var cX = width / 2;
    var cY = height / 2;
    var dX = x - cX; // deltaX )
    var dY = y - cY; // deltaY
    var radius = (500 - 30) / 2;

    var hue = this.getAngle(dX, dY); // degrees, clockwise from right
    var relativeDistance = this.getDistance(dX, dY) / radius; // edge of radius = 1
    var sat = Math.min(relativeDistance, 1); // Distance from center
    return this.HSVtoRGB(hue, sat, 1);
  }


  drawGradient() {
    var width = 500;
    var height = 500;
    this.canvas.width = width;
    this.canvas.height = height;
    var context = this.context;
    var x = width / 2;
    var y = height / 2;
    var radius = (Math.min(width, height) - 30) / 2;
    var counterClockwise = false;

    function drawCircle() {
      for (var angle = 0; angle <= 360; angle += 1) {
        var startAngle = (angle - 2) * (Math.PI / 180);
        var endAngle = angle * (Math.PI / 180);
        context.beginPath();
        context.moveTo(x, y);
        context.arc(x, y, radius, startAngle, endAngle, counterClockwise);
        context.closePath();
        var gradient = context.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0.1, 'hsl(' + angle + ', 100%, 100%)');
        gradient.addColorStop(0.55, 'hsl(' + angle + ', 100%, 80%)');
        gradient.addColorStop(0.95, 'hsl(' + angle + ', 100%, 51%)');
        context.fillStyle = gradient;
        context.fill();
      }
    }

    function drawShadow() {
      context.save();
      context.beginPath();
      context.arc(x, y, radius, 0, 2 * Math.PI, false);
      context.shadowOffsetX = 3;
      context.shadowOffsetY = 3;
      context.shadowBlur = 14;
      context.shadowColor = 'grey';
      context.fillStyle = 'white';
      context.fill();
      context.restore();
    }

    function drawBorder() {
      context.beginPath();
      context.arc(x, y, radius, 0, 2 * Math.PI, false);
      context.lineWidth = 6;
      context.strokeStyle = 'white';
      context.stroke();
    }
    drawShadow();
    drawCircle();
    drawBorder();
  }

  /**
  * modified from:
  * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
  * this takes h = hue (0-360), s = saturation (0-1), v = value (0-1)
  */

  /* eslint-disable one-var, no-mixed-operators, one-var-declaration-per-line */
  HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    // if (arguments.length === 1) {
    //   s = h.s; v = h.v; h = h.h;
    // }
    h = h / 360;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    /* eslint-disable default-case, no-sequences, no-unused-expressions */
    switch (i % 6) {
      case 0: r = v, g = t, b = p; break;
      case 1: r = q, g = v, b = p; break;
      case 2: r = p, g = v, b = t; break;
      case 3: r = p, g = q, b = v; break;
      case 4: r = t, g = p, b = v; break;
      case 5: r = v, g = p, b = q; break;
    }
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }
}
customElements.define(HaColorPicker.is, HaColorPicker);
</script>
