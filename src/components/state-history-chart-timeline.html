<link rel='import' href='../../bower_components/polymer/polymer.html'>
<link rel='import' href='./entity/ha-chart-base.html'>

<dom-module id='state-history-chart-timeline'>
  <template>
      <ha-chart-base publish data="[[chartData]]"></ha-chart-base>
  </template>
</dom-module>
<script>

class StateHistoryChartTimeline extends Polymer.Element {
  static get is() { return 'state-history-chart-timeline'; }
  static get properties() {
    return {
      data: {
        type: Object,
        observer: 'dataChanged',
      },
      noSingle: Boolean,
      endTime: Date,
    };
  }

  static get observers() {
    return ['dataChanged(data, endTime)'];
  }

  connectedCallback() {
    super.connectedCallback();
    this._isAttached = true;
    this.drawChart();
    // this.addEventListener('iron-resize', () => {
    //   this.async(this.drawChart, 10);
    // });
  }

  dataChanged() {
    this.drawChart();
  }

  drawChart() {
    var getColorFunc = function () {
      var colorArray = ['red', 'blue', 'green', 'navy', 'grey', 'purple', 'orange'];
      var colorTable = {
        on: 'green',
        off: 'red',
        idle: 'blue',
        unavailable: 'lightgrey',
      };
      var colors = 3;
      return function colorFunction(data) {
        var dataLabel = data[2];
        var x;
        if (dataLabel) {
          x = colorTable[dataLabel];
          if (!x) {
            x = colorArray[colors++];
            colorTable[dataLabel] = x;
          }
        } else {
          x = colorArray[Math.floor(Math.random() * colorArray.length)];
        }
        return x;
      };
    };
    var stateHistory = this.data;
    var startTime;
    var endTime;

    if (!this._isAttached) {
      return;
    }

    if (!stateHistory) {
      // || stateHistory.length === 0) {
      stateHistory = [];
    }

    startTime = new Date(stateHistory.reduce(function (minTime, stateInfo) {
      return Math.min(minTime, new Date(stateInfo.data[0].last_changed));
    }, new Date()));

    // end time is Math.max(startTime, last_event)
    endTime = this.endTime ||
      new Date(stateHistory.reduce(function (maxTime, stateInfo) {
        return Math.max(
          maxTime,
          new Date(stateInfo.data[stateInfo.data.length - 1].last_changed)
        );
      }, startTime));

    if (endTime > new Date()) {
      endTime = new Date();
    }

    var labels = [];
    var datasets = [];
    // stateHistory is a list of lists of sorted state objects
    stateHistory.forEach(function (stateInfo) {
      var entityDisplay;
      var newLastChanged;
      var prevState = null;
      var prevLastChanged = null;
      var dataRow = [];

      // if (stateInfo.data.length === 0) return;

      entityDisplay = stateInfo.name;

      stateInfo.data.forEach(function (state) {
        var timeStamp = new Date(state.last_changed);
        if (timeStamp > endTime) {
          // Drop datapoints that are after the requested endTime. This could happen if
          // endTime is 'now' and client time is not in sync with server time.
          return;
        }
        if (prevState !== null && state.state !== prevState) {
          newLastChanged = new Date(state.last_changed);

          dataRow.push([prevLastChanged, newLastChanged, prevState]);

          prevState = state.state;
          prevLastChanged = newLastChanged;
        } else if (prevState === null) {
          prevState = state.state;
          prevLastChanged = new Date(state.last_changed);
        }
      });

      dataRow.push([prevLastChanged, endTime, prevState]);
      datasets.push({ data: dataRow });
      labels.push(entityDisplay);
    });

    var chartOptions = {
      type: 'timeline',
      options: {
        colorFunction: getColorFunc(),
        tooltips: {
          mode: 'nearest',
        }
      },
      data: {
        labels: labels,
        datasets: datasets
      }
    };
    this.chartData = chartOptions;
  }
}
customElements.define(StateHistoryChartTimeline.is, StateHistoryChartTimeline);

</script>
