<script src='../../bower_components/fecha/fecha.min.js'></script>
<script src='../../build-temp/util.js'></script>

<!--
collection of utility functions.
-->
<script>
window.hassUtil = window.hassUtil || {};

window.hassUtil.DEFAULT_ICON = 'hass:bookmark';

window.hassUtil.OFF_STATES = ['off', 'closed', 'unlocked'];

window.hassUtil.DOMAINS_WITH_NO_HISTORY = ['camera', 'configurator', 'history_graph', 'scene'];

// Update root's child element to be newElementTag replacing another existing child if any.
// Copy attributes into the child element.
window.hassUtil.dynamicContentUpdater = function (root, newElementTag, attributes) {
  var rootEl = Polymer.dom(root);
  var customEl;

  if (rootEl.lastChild && rootEl.lastChild.tagName === newElementTag) {
    customEl = rootEl.lastChild;
  } else {
    if (rootEl.lastChild) {
      rootEl.removeChild(rootEl.lastChild);
    }
    // Creating an element with upper case works fine in Chrome, but in FF it doesn't immediately
    // become a defined Custom Element. Polymer does that in some later pass.
    customEl = document.createElement(newElementTag.toLowerCase());
  }

  if (customEl.setProperties) {
    customEl.setProperties(attributes);
  } else {
    // If custom element definition wasn't loaded yet - setProperties would be
    // missing, but no harm in setting attributes one-by-one then.
    Object.keys(attributes).forEach((key) => {
      customEl[key] = attributes[key];
    });
  }

  if (customEl.parentNode === null) {
    rootEl.appendChild(customEl);
  }
};

window.hassUtil.relativeTime = function (dateObj) {
  var delta = (new Date() - dateObj) / 1000;
  var format = delta >= 0 ? '%s ago' : 'in %s';
  delta = Math.abs(delta);
  var tests = window.hassUtil.relativeTime.tests;
  var i;

  for (i = 0; i < tests.length; i += 2) {
    if (delta < tests[i]) {
      delta = Math.floor(delta);
      return format.replace(
        '%s',
        delta === 1 ? '1 ' + tests[i + 1] : delta + ' ' + tests[i + 1] + 's'
      );
    }

    delta /= tests[i];
  }

  delta = Math.floor(delta);
  return format.replace('%s', delta === 1 ? '1 week' : delta + ' weeks');
};

window.hassUtil.relativeTime.tests = [
  60, 'second',
  60, 'minute',
  24, 'hour',
  7, 'day',
];

window.hassUtil.domainIcon = function (domain, state) {
  switch (domain) {
    case 'alarm_control_panel':
      switch (state) {
        case 'armed_home':
          return 'hass:bell-plus';
        case 'armed_night':
          return 'hass:bell-sleep';
        case 'disarmed':
          return 'hass:bell-outline';
        case 'triggered':
          return 'hass:bell-ring';
        default:
          return 'hass:bell';
      }

    case 'automation':
      return 'hass:playlist-play';

    case 'binary_sensor':
      return state && state === 'off' ? 'hass:radiobox-blank' : 'hass:checkbox-marked-circle';

    case 'calendar':
      return 'hass:calendar';

    case 'camera':
      return 'hass:video';

    case 'climate':
      return 'hass:thermostat';

    case 'configurator':
      return 'hass:settings';

    case 'conversation':
      return 'hass:text-to-speech';

    case 'cover':
      return state && state === 'open' ? 'hass:window-open' : 'hass:window-closed';

    case 'device_tracker':
      return 'hass:account';

    case 'fan':
      return 'hass:fan';

    case 'history_graph':
      return 'hass:chart-line';

    case 'group':
      return 'hass:google-circles-communities';

    case 'homeassistant':
      return 'hass:home-assistant';

    case 'image_processing':
      return 'hass:image-filter-frames';

    case 'input_boolean':
      return 'hass:drawing';

    case 'input_datetime':
      return 'hass:calendar-clock';

    case 'input_select':
      return 'hass:format-list-bulleted';

    case 'input_number':
      return 'hass:ray-vertex';

    case 'input_text':
      return 'hass:textbox';

    case 'light':
      return 'hass:lightbulb';

    case 'lock':
      return state && state === 'unlocked' ? 'hass:lock-open' : 'hass:lock';

    case 'mailbox':
      return 'hass:mailbox';

    case 'media_player':
      return state && state !== 'off' && state !== 'idle' ?
        'hass:cast-connected' : 'hass:cast';

    case 'notify':
      return 'hass:comment-alert';

    case 'plant':
      return 'hass:flower';

    case 'proximity':
      return 'hass:apple-safari';

    case 'remote':
      return 'hass:remote';

    case 'scene':
      return 'hass:google-pages';

    case 'script':
      return 'hass:file-document';

    case 'sensor':
      return 'hass:eye';

    case 'simple_alarm':
      return 'hass:bell';

    case 'sun':
      return 'hass:white-balance-sunny';

    case 'switch':
      return 'hass:flash';

    case 'timer':
      return 'hass:timer';

    case 'updater':
      return 'hass:cloud-upload';

    case 'vacuum':
      return 'mdi:robot-vacuum';

    case 'weblink':
      return 'hass:open-in-new';

    case 'zwave':
      switch (state) {
        case 'dead':
          return 'hass:emoticon-dead';
        case 'sleeping':
          return 'hass:sleep';
        case 'initializing':
          return 'hass:timer-sand';
        default:
          return 'hass:nfc';
      }

    default:
      /* eslint-disable no-console */
      console.warn('Unable to find icon for domain ' + domain + ' (' + state + ')');
      /* eslint-enable no-console */
      return window.hassUtil.DEFAULT_ICON;
  }
};

window.hassUtil.binarySensorIcon = function (state) {
  var activated = state.state && state.state === 'off';
  switch (state.attributes.device_class) {
    case 'battery':
      return activated ? 'hass:battery' : 'hass:battery-outline';
    case 'cold':
      return activated ? 'hass:thermometer' : 'hass:snowflake';
    case 'connectivity':
      return activated ? 'hass:server-network-off' : 'hass:server-network';
    case 'door':
      return activated ? 'hass:door-closed' : 'hass:door-open';
    case 'garage_door':
      return activated ? 'hass:garage' : 'hass:garage-open';
    case 'gas':
    case 'power':
    case 'problem':
    case 'safety':
    case 'smoke':
      return activated ? 'hass:verified' : 'hass:alert';
    case 'heat':
      return activated ? 'hass:thermometer' : 'hass:fire';
    case 'light':
      return activated ? 'hass:brightness-5' : 'hass:brightness-7';
    case 'lock':
      return activated ? 'hass:lock' : 'hass:lock-open';
    case 'moisture':
      return activated ? 'hass:water-off' : 'hass:water';
    case 'motion':
      return activated ? 'hass:walk' : 'hass:run';
    case 'occupancy':
      return activated ? 'hass:home-outline' : 'hass:home';
    case 'opening':
      return activated ? 'hass:square' : 'hass:square-outline';
    case 'plug':
      return activated ? 'hass:power-plug-off' : 'hass:power-plug';
    case 'presence':
      return activated ? 'hass:home-outline' : 'hass:home';
    case 'sound':
      return activated ? 'hass:music-note-off' : 'hass:music-note';
    case 'vibration':
      return activated ? 'hass:crop-portrait' : 'hass:vibrate';
    case 'window':
      return activated ? 'hass:window-closed' : 'hass:window-open';
    default:
      return activated ? 'hass:radiobox-blank' : 'hass:checkbox-marked-circle';
  }
};

window.hassUtil.coverIcon = function (state) {
  var open = state.state && state.state !== 'closed';
  switch (state.attributes.device_class) {
    case 'garage':
      return open ? 'hass:garage-open' : 'hass:garage';
    default:
      return open ? 'hass:window-open' : 'hass:window-closed';
  }
};

window.hassUtil.sensorIcon = (state) => {
  switch (state.attributes.device_class) {
    case 'battery': {
      if (isNaN(state.state)) {
        return 'mdi:battery-unknown';
      }
      const batteryRound = Math.round(state.state / 10) * 10;
      if (batteryRound >= 100) {
        return 'mdi:battery';
      }
      if (batteryRound <= 0) {
        return 'mdi:battery-alert';
      }
      return `mdi:battery-${batteryRound}`;
    }
    case 'humidity':
      return 'mdi:water-percent';
    case 'temperature':
      return 'mdi:thermometer';
    default:
      return 'mdi:eye';
  }
};

window.hassUtil.stateIcon = function (state) {
  if (!state) {
    return window.hassUtil.DEFAULT_ICON;
  } else if (state.attributes.icon) {
    return state.attributes.icon;
  }

  const unit = state.attributes.unit_of_measurement;
  const domain = window.hassUtil.computeDomain(state);

  if (domain === 'sensor' && state.attributes.device_class) {
    return window.hassUtil.sensorIcon(state);
  } else if (domain === 'sensor' && unit) {
    if (unit === '°C' || unit === '°F') {
      return 'hass:thermometer';
    } else if (unit === 'Mice') {
      return 'hass:mouse-variant';
    }
  } else if (domain === 'binary_sensor') {
    return window.hassUtil.binarySensorIcon(state);
  } else if (domain === 'cover') {
    return window.hassUtil.coverIcon(state);
  } else if (domain === 'input_datetime') {
    if (!state.attributes.has_date) {
      return 'hass:clock';
    } else if (!state.attributes.has_time) {
      return 'hass:calendar';
    }
  }

  return window.hassUtil.domainIcon(domain, state.state);
};

window.hassUtil.computeObjectId = function (stateObj) {
  if (!stateObj._object_id) {
    stateObj._object_id = window.HAWS.extractObjectId(stateObj.entity_id);
  }

  return stateObj._object_id;
};

window.hassUtil.computeStateName = function (stateObj) {
  if (stateObj._entityDisplay === undefined) {
    stateObj._entityDisplay = (
      stateObj.attributes.friendly_name ||
      window.HAWS.extractObjectId(stateObj.entity_id)
        .replace(/_/g, ' '));
  }

  return stateObj._entityDisplay;
};

window.hassUtil.sortByName = function (entityA, entityB) {
  var nameA = window.hassUtil.computeStateName(entityA);
  var nameB = window.hassUtil.computeStateName(entityB);
  if (nameA < nameB) {
    return -1;
  }
  if (nameA > nameB) {
    return 1;
  }
  return 0;
};

window.hassUtil.isComponentLoaded = function (hass, component) {
  return hass && hass.config.core.components.indexOf(component) !== -1;
};

window.hassUtil.computeLocationName = function (hass) {
  return hass && hass.config.core.location_name;
};

window.hassUtil.applyThemesOnElement = function (element, themes, localTheme, updateMeta) {
  if (!element._themes) {
    element._themes = {};
  }
  let themeName = themes.default_theme;
  if (localTheme === 'default' || (localTheme && themes.themes[localTheme])) {
    themeName = localTheme;
  }
  const styles = Object.assign({}, element._themes);
  if (themeName !== 'default') {
    var theme = themes.themes[themeName];
    Object.keys(theme).forEach((key) => {
      var prefixedKey = '--' + key;
      element._themes[prefixedKey] = '';
      styles[prefixedKey] = theme[key];
    });
  }
  // implement updateStyles() method of Polemer elements
  if (window.ShadyCSS) {
    window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(element), styles);
  }

  if (!updateMeta) return;

  const meta = document.querySelector('meta[name=theme-color]');
  if (meta) {
    if (!meta.hasAttribute('default-content')) {
      meta.setAttribute('default-content', meta.getAttribute('content'));
    }
    const themeColor = styles['--primary-color'] || meta.getAttribute('default-content');
    meta.setAttribute('content', themeColor);
  }
};
</script>
