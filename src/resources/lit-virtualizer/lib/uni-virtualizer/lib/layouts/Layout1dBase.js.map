{"version":3,"file":"Layout1dBase.js","sourceRoot":"","sources":["../../../../src/lib/uni-virtualizer/lib/layouts/Layout1dBase.ts"],"names":[],"mappings":"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","sourcesContent":["import EventTarget from '../polyfillLoaders/EventTarget.js';\nimport {Layout, Positions, ScrollDirection, Size, dimension, position} from './Layout.js';\n\ntype UpdateVisibleIndicesOptions = {\n  emit?: boolean\n}\n\nexport interface Layout1dBaseConfig {\n  direction?: ScrollDirection,\n  totalItems?: number\n}\n\nexport abstract class Layout1dBase<C extends Layout1dBaseConfig> implements Layout {\n  /**\n   * The last set viewport scroll position.\n   */\n  private _latestCoords: Positions = {left: 0, top: 0};\n\n  /**\n   * Scrolling direction.\n   */\n  private _direction: ScrollDirection = 'vertical';\n\n  /**\n   * Dimensions of the viewport.\n   */\n  private _viewportSize: Size = {width: 0, height: 0};\n\n  /**\n   * Flag for debouncing asynchnronous reflow requests.\n   */\n  private _pendingReflow = false;\n\n  private _pendingLayoutUpdate = false;\n\n  /**\n   * Index of the item that has been scrolled to via the public API. When the\n   * container is otherwise scrolled, this value is set back to -1.\n   */\n  protected _scrollToIndex = -1;\n\n  /**\n   * When a child is scrolled to, the offset from the top of the child and the\n   * top of the viewport. Value is a proportion of the item size.\n   */\n  private _scrollToAnchor = 0;\n\n  /**\n   * The index of the first item intersecting the viewport.\n   */\n  private _firstVisible = 0;\n\n  /**\n   * The index of the last item intersecting the viewport.\n   */\n  private _lastVisible = 0;\n\n  private _eventTargetPromise: Promise<void> = (EventTarget().then((Ctor) => {\n    this._eventTarget = new Ctor();\n  }));\n\n  /**\n   * Pixel offset in the scroll direction of the first child.\n   */\n  protected _physicalMin = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the last child.\n   */\n  protected _physicalMax = 0;\n\n  /**\n   * Index of the first child.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child.\n   */\n  protected _last = -1;\n\n  /**\n   * The _estimated_ size of a child.\n   */\n  protected _itemSize: Size = {width: 100, height: 100};\n\n  /**\n   * Space in pixels between children.\n   */\n  protected _spacing = 0;\n\n  /**\n   * Length in the scrolling direction.\n   */\n  protected _sizeDim: dimension = 'height';\n\n  /**\n   * Length in the non-scrolling direction.\n   */\n  protected _secondarySizeDim: dimension = 'width';\n\n  /**\n   * Position in the scrolling direction.\n   */\n  protected _positionDim: position = 'top';\n\n  /**\n   * Position in the non-scrolling direction.\n   */\n  protected _secondaryPositionDim: position = 'left';\n\n  /**\n   * Current scroll offset in pixels.\n   */\n  protected _scrollPosition = 0;\n\n  /**\n   * Difference between current scroll offset and scroll offset calculated due\n   * to a reflow.\n   */\n  protected _scrollError = 0;\n\n  /**\n   * Total number of items that could possibly be displayed. Used to help\n   * calculate the scroll size.\n   */\n  protected _totalItems = 0;\n\n  /**\n   * The total (estimated) length of all items in the scrolling direction.\n   */\n  protected _scrollSize = 1;\n\n  /**\n   * Number of pixels beyond the visible size of the container to still include\n   * in the active range of items.\n   */\n  // TODO (graynorton): Probably want to make this something we calculate based\n  // on viewport size, item size, other factors, possibly still with a dial of some kind\n  protected _overhang = 1000;\n\n  private _eventTarget: EventTarget | null = null;\n  protected _spacingChanged = false;\n\n  protected _defaultConfig: C = {\n    direction: 'vertical'\n  } as C\n\n  constructor(config?: C) {\n    this.config = config || this._defaultConfig;\n  }\n\n  set config(config: C) {\n    Object.assign(this, Object.assign({}, this._defaultConfig, config));\n  }\n\n  get config(): C {\n    return {\n      direction: this.direction\n    } as C;\n  }\n\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get totalItems(): number {\n    return this._totalItems;\n  }\n  set totalItems(num) {\n    const _num = Number(num);\n    if (_num !== this._totalItems) {\n      this._totalItems = _num;\n      this._scheduleReflow();\n    }\n  }\n\n  /**\n   * Primary scrolling direction.\n   */\n  get direction(): ScrollDirection {\n    return this._direction;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = (dir === 'horizontal') ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = (dir === 'horizontal') ? 'width' : 'height';\n      this._secondarySizeDim = (dir === 'horizontal') ? 'height' : 'width';\n      this._positionDim = (dir === 'horizontal') ? 'left' : 'top';\n      this._secondaryPositionDim = (dir === 'horizontal') ? 'top' : 'left';\n      this._scheduleLayoutUpdate();\n    }\n  }\n\n  /**\n   * Estimate of the dimensions of a single child.\n   */\n  get itemSize(): Size {\n    return this._itemSize;\n  }\n  set itemSize(dims) {\n    const {_itemDim1, _itemDim2} = this;\n    Object.assign(this._itemSize, dims);\n    if (_itemDim1 !== this._itemDim1 || _itemDim2 !== this._itemDim2) {\n      if (_itemDim2 !== this._itemDim2) {\n        this._itemDim2Changed();\n      } else {\n        this._scheduleLayoutUpdate();\n      }\n    }\n  }\n\n  /**\n   * Amount of space in between items.\n   */\n  get spacing(): number {\n    return this._spacing;\n  }\n  set spacing(px) {\n    const _px = Number(px);\n    if (_px !== this._spacing) {\n      this._spacing = _px;\n      this._scheduleLayoutUpdate();\n    }\n  }\n\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize(): Size {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {_viewDim1, _viewDim2} = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      this._viewDim2Changed();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll(): Positions {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    if (oldPos !== this._scrollPosition) {\n      this._scrollPositionChanged(oldPos, this._scrollPosition);\n      this._updateVisibleIndices({emit: true});\n    }\n    this._checkThresholds();\n  }\n\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force: boolean) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n\n  /**\n   * Scroll to the child at the given index, and the given position within that\n   * child.\n   */\n  scrollToIndex(index: number, position = 'start') {\n    if (!Number.isFinite(index))\n      return;\n    index = Math.min(this.totalItems, Math.max(0, index));\n    this._scrollToIndex = index;\n    if (position === 'nearest') {\n      position = index > this._first + this._num / 2 ? 'end' : 'start';\n    }\n    switch (position) {\n      case 'start':\n        this._scrollToAnchor = 0;\n        break;\n      case 'center':\n        this._scrollToAnchor = 0.5;\n        break;\n      case 'end':\n        this._scrollToAnchor = 1;\n        break;\n      default:\n        throw new TypeError(\n            'position must be one of: start, center, end, nearest');\n    }\n    this._scheduleReflow();\n  }\n\n  async dispatchEvent(evt: Event) {\n    await this._eventTargetPromise;\n    this._eventTarget!.dispatchEvent(evt);\n  }\n\n  async addEventListener(type: string, listener: EventListener | EventListenerObject | null, options?: boolean | AddEventListenerOptions | undefined) {\n    await this._eventTargetPromise;\n    this._eventTarget!.addEventListener(type, listener, options);\n  }\n\n  async removeEventListener(type: string, callback: EventListener | EventListenerObject | null, options?: boolean | EventListenerOptions | undefined) {\n    await this._eventTargetPromise;\n    this._eventTarget!.removeEventListener(type, callback, options);\n  }\n\n  /**\n   * Get the top and left positioning of the item at idx.\n   */\n  abstract _getItemPosition(idx: number): Positions;\n\n  /**\n   * Update _first and _last based on items that should be in the current\n   * range.\n   */\n  abstract _getActiveItems(): void;\n\n  protected _itemDim2Changed() {\n    // Override\n  }\n\n  protected _viewDim2Changed() {\n    // Override\n  }\n\n  protected _updateLayout() {\n    // Override\n  }\n\n  protected _getItemSize(_idx: number): Size {\n    return {\n      [this._sizeDim]: this._itemDim1,\n      [this._secondarySizeDim]: this._itemDim2,\n    } as unknown as Size;\n  }\n\n  /**\n   * The size of an item in the scrolling direction + space between items.\n   */\n  protected get _delta(): number {\n    return this._itemDim1 + this._spacing;\n  }\n\n  /**\n   * The height or width of an item, whichever corresponds to the scrolling direction.\n   */\n  protected get _itemDim1(): number {\n    return this._itemSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of an item, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _itemDim2(): number {\n    return this._itemSize[this._secondarySizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  protected get _viewDim1(): number {\n    return this._viewportSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _viewDim2(): number {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  protected _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  protected _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n\n  protected _reflow() {\n    const {_first, _last, _scrollSize} = this;\n\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._getActiveItems();\n    this._scrollIfNeeded();\n    this._updateVisibleIndices();\n\n    if (this._scrollSize !== _scrollSize) {\n      this._emitScrollSize();\n    }\n\n    if (this._first === -1 && this._last === -1) {\n      // TODO: have default empty object for emitRange instead\n      this._emitRange();\n    } else if (\n        this._first !== _first || this._last !== _last ||\n        this._spacingChanged) {\n      // TODO: have default empty object for emitRange instead\n      this._emitRange();\n      this._emitChildPositions();\n    }\n    this._emitScrollError();\n  }\n\n  /**\n   * Estimates the total length of all items in the scrolling direction, including spacing.\n   */\n  protected _updateScrollSize() {\n    // Ensure we have at least 1px - this allows getting at least 1 item to be\n    // rendered.\n    this._scrollSize = Math.max(1, this._totalItems * this._delta);\n  }\n\n  protected _scrollIfNeeded() {\n    if (this._scrollToIndex === -1) {\n      return;\n    }\n    const index = this._scrollToIndex;\n    const anchor = this._scrollToAnchor;\n    const pos = this._getItemPosition(index)[this._positionDim];\n    const size = this._getItemSize(index)[this._sizeDim];\n\n    const curAnchorPos = this._scrollPosition + this._viewDim1 * anchor;\n    const newAnchorPos = pos + size * anchor;\n    // Ensure scroll position is an integer within scroll bounds.\n    const scrollPosition = Math.floor(Math.min(\n        this._scrollSize - this._viewDim1,\n        Math.max(0, this._scrollPosition - curAnchorPos + newAnchorPos)));\n    this._scrollError += this._scrollPosition - scrollPosition;\n    this._scrollPosition = scrollPosition;\n  }\n\n  protected _emitRange(inProps: unknown = undefined) {\n    const detail = Object.assign(\n        {\n          first: this._first,\n          last: this._last,\n          num: this._num,\n          stable: true,\n          firstVisible: this._firstVisible,\n          lastVisible: this._lastVisible,\n        },\n        inProps);\n    this.dispatchEvent(new CustomEvent('rangechange', {detail}));\n  }\n\n  protected _emitScrollSize() {\n    const detail = {\n      [this._sizeDim]: this._scrollSize,\n    };\n    this.dispatchEvent(new CustomEvent('scrollsizechange', {detail}));\n  }\n\n  protected _emitScrollError() {\n    if (this._scrollError) {\n      const detail = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0,\n      };\n      this.dispatchEvent(new CustomEvent('scrollerrorchange', {detail}));\n      this._scrollError = 0;\n    }\n  }\n\n  /**\n   * Get or estimate the top and left positions of items in the current range.\n   * Emit an itempositionchange event with these positions.\n   */\n  protected _emitChildPositions() {\n    const detail: {[key: number]: Positions} = {};\n    for (let idx = this._first; idx <= this._last; idx++) {\n      detail[idx] = this._getItemPosition(idx);\n    }\n    this.dispatchEvent(new CustomEvent('itempositionchange', {detail}));\n  }\n\n  /**\n   * Number of items to display.\n   */\n  private get _num(): number {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n\n  private _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(\n          this._scrollSize,\n          this._scrollPosition + this._viewDim1 + this._overhang);\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      }\n    }\n  }\n\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n   protected _updateVisibleIndices(options?: UpdateVisibleIndicesOptions) {\n    if (this._first === -1 || this._last === -1) return;\n\n    let firstVisible = this._first;\n    while (\n      Math.round(\n        this._getItemPosition(firstVisible)[this._positionDim] +\n        this._getItemSize(firstVisible)[this._sizeDim]\n      )\n      <=\n      Math.round (this._scrollPosition)\n     ) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n    while (\n      Math.round(this._getItemPosition(lastVisible)[this._positionDim])\n      >=\n      Math.round(this._scrollPosition + this._viewDim1)\n    ) {\n      lastVisible--;\n    }\n\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._emitRange();\n      }\n    }\n  }\n\n  private _scrollPositionChanged(oldPos: number, newPos: number) {\n    // When both values are bigger than the max scroll position, keep the\n    // current _scrollToIndex, otherwise invalidate it.\n    const maxPos = this._scrollSize - this._viewDim1;\n    if (oldPos < maxPos || newPos < maxPos) {\n      this._scrollToIndex = -1;\n    }\n  }\n}\n"]}