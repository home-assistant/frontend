<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/paper-scroll-header-panel/paper-scroll-header-panel.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">

<link rel="import" href="../components/ha-cards.html">
<link rel="import" href="../components/ha-view-tabs.html">

<dom-module id="partial-cards">
  <template>
    <style is="custom-style" include="iron-flex iron-positioning"></style>
    <style>
      :host {
        display: block;
        -ms-user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
      }

      paper-scroll-header-panel {
        --paper-scroll-header-panel-container: {
          background-color: #E5E5E5;
        };
      }

      paper-scroll-header-panel[has-views] paper-toolbar {
        height: 104px;
      }

      paper-toolbar:after {
        content: "";
        position: absolute;
        left: 0px;
        right: 0px;
        bottom: -5px;
        width: 100%;
        height: 5px;
        pointer-events: none;
        opacity: 0;
        box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
        will-change: opacity;
        transition: opacity 0.4s;
      }

      paper-scroll-header-panel.raised paper-toolbar:after {
        opacity: 1;
      }

      .menu-icon {
        margin-right: 24px;
      }

      #menu > .title {
        line-height: 40px;
      }

      #menu > .title > span {
        pointer-events: auto;
      }

      .views {
        padding-left: 12px;
        --paper-tabs-selection-bar-color: #FFF;
      }
    </style>

    <paper-scroll-header-panel id='panel'
      condenses keep-condensed-header class='fit' has-views$='[[hasViews]]'
      header-height="[[computeHeaderHeight(hasViews, narrow)]]"
      condensed-header-height="[[computeCondensedHeaderHeight(hasViews, narrow)]]"
      on-paper-header-transform='headerScrollAdjust'
      on-content-scroll='contentScroll'
      >
      <paper-toolbar>
        <div class='flex layout horizontal' id='menu'>
          <paper-icon-button icon='mdi:menu' class$='[[computeMenuButtonClass(narrow, showMenu)]]' on-tap='toggleMenu'></paper-icon-button>

          <span class='title flex'>
            <span on-tap='scrollToTop'>
              [[computeTitle(hasViews, locationName)]]
            </span>
          </span>

          <paper-icon-button
            icon="mdi:refresh"
            class$="[[computeRefreshButtonClass(isFetching)]]"
            on-tap="handleRefresh" hidden$="[[isStreaming]]"
          ></paper-icon-button>
          <paper-icon-button
            icon="mdi:microphone" hidden$='[[!canListen]]'
            on-tap="handleListenClick"></paper-icon-button>
        </div>

        <template is='dom-if' if='[[hasViews]]'>
          <div class='fit bottom views'>
            <ha-view-tabs hass='[[hass]]' on-view-tapped='scrollToTop'></ha-view-tabs>
          </div>
        </template>
      </paper-toolbar>

      <ha-cards
        show-introduction='[[computeShowIntroduction(currentView, introductionLoaded, states)]]'
        states='[[states]]' columns='[[columns]]' hass='[[hass]]'></ha-cards>
    </paper-header-panel>
  </template>

</dom-module>

<script>
Polymer({
  is: 'partial-cards',

  behaviors: [window.hassBehavior],

  properties: {
    hass: {
      type: Object,
    },

    narrow: {
      type: Boolean,
      value: false,
    },

    isFetching: {
      type: Boolean,
      bindNuclear: function (hass) {
        return hass.syncGetters.isFetching;
      },
    },

    isStreaming: {
      type: Boolean,
      bindNuclear: function (hass) {
        return hass.streamGetters.isStreamingEvents;
      },
    },

    canListen: {
      type: Boolean,
      bindNuclear: function (hass) {
        return [
          hass.voiceGetters.isVoiceSupported,
          hass.configGetters.isComponentLoaded('conversation'),
          function (isVoiceSupported, componentLoaded) {
            return isVoiceSupported && componentLoaded;
          },
        ];
      },
    },

    introductionLoaded: {
      type: Boolean,
      bindNuclear: function (hass) {
        return hass.configGetters.isComponentLoaded('introduction');
      },
    },

    locationName: {
      type: String,
      bindNuclear: function (hass) {
        return hass.configGetters.locationName;
      },
    },

    showMenu: {
      type: Boolean,
      value: false,
      observer: 'windowChange',
    },

    currentView: {
      type: String,
      bindNuclear: function (hass) {
        return [
          hass.viewGetters.currentView,
          function (view) { return view || ''; },
        ];
      },
    },

    hasViews: {
      type: Boolean,
      bindNuclear: function (hass) {
        return [
          hass.viewGetters.views,
          function (views) { return views.size > 0; },
        ];
      },
    },

    states: {
      type: Object,
      bindNuclear: function (hass) {
        return hass.viewGetters.currentViewEntities;
      },
    },

    columns: {
      type: Number,
      value: 1,
    },
  },

  created: function () {
    var sizes = [];
    var col;
    this.windowChange = this.windowChange.bind(this);
    for (col = 0; col < 5; col++) {
      sizes.push(300 + (col * 300));
    }
    this.mqls = sizes.map(function (width) {
      var mql = window.matchMedia('(min-width: ' + width + 'px)');
      mql.addListener(this.windowChange);
      return mql;
    }.bind(this));
  },

  detached: function () {
    this.mqls.forEach(function (mql) {
      mql.removeListener(this.windowChange);
    });
  },

  windowChange: function () {
    var matchColumns = this.mqls.reduce(function (cols, mql) { return cols + mql.matches; }, 0);
    // Do -1 column if the menu is docked and open
    this.columns = Math.max(1, matchColumns - (!this.narrow && this.showMenu));
  },

  scrollToTop: function () {
    this.$.panel.scrollToTop(true);
  },

  handleRefresh: function () {
    this.hass.syncActions.fetchAll();
  },

  handleListenClick: function () {
    this.hass.voiceActions.listen();
  },

  contentScroll: function () {
    if (this.debouncedContentScroll) return;

    this.debouncedContentScroll = this.async(function () {
      this.checkRaised();
      this.debouncedContentScroll = false;
    }.bind(this), 100);
  },

  checkRaised: function () {
    this.toggleClass(
      'raised',
      this.$.panel.scroller.scrollTop > (this.hasViews ? 56 : 0),
      this.$.panel);
  },

  headerScrollAdjust: function (ev) {
    if (!this.hasViews) return;
    this.translate3d('0', '-' + ev.detail.y + 'px', '0', this.$.menu);
    // this.toggleClass('condensed', ev.detail.y === 56, this.$.panel);
  },

  computeHeaderHeight: function (hasViews, narrow) {
    if (hasViews) {
      return 104;
    } else if (narrow) {
      return 56;
    }
    return 64;
  },

  computeCondensedHeaderHeight: function (hasViews, narrow) {
    if (hasViews) {
      return 48;
    } else if (narrow) {
      return 56;
    }
    return 64;
  },

  computeMenuButtonClass: function (narrow, showMenu) {
    return !narrow && showMenu ? 'menu-icon invisible' : 'menu-icon';
  },

  computeRefreshButtonClass: function (isFetching) {
    return isFetching ? 'ha-spin' : '';
  },

  computeTitle: function (hasViews, locationName) {
    return hasViews ? 'Home Assistant' : locationName;
  },

  computeShowIntroduction: function (currentView, introductionLoaded, states) {
    return currentView === '' && (introductionLoaded || states.size === 0);
  },

  computeHasViews: function (views) {
    return views.length > 0;
  },

  toggleMenu: function () {
    this.fire('open-menu');
  },
});
</script>
