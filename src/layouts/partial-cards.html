<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">

<link rel="import" href="../../bower_components/app-layout/app-header-layout/app-header-layout.html">
<link rel="import" href="../../bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
<link rel="import" href="../../bower_components/app-layout/app-header/app-header.html">
<link rel="import" href="../../bower_components/app-layout/app-toolbar/app-toolbar.html">

<link rel="import" href="../components/ha-menu-button.html">
<link rel="import" href="../components/ha-cards.html">
<link rel="import" href="../components/ha-view-tabs.html">

<dom-module id="partial-cards">
  <template>
    <style include="iron-flex iron-positioning ha-style">
      :host {
        -ms-user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
      }

      app-header-layout {
        background-color: #E5E5E5;
      }

      ha-view-tabs {
        margin-left: 12px;
        --paper-tabs-selection-bar-color: #FFF;
      }
    </style>

    <app-header-layout has-scrolling-region id='layout'>
      <app-header effects="waterfall" condenses fixed>
        <app-toolbar>
          <ha-menu-button narrow='[[narrow]]' show-menu='[[showMenu]]'></ha-menu-button>
          <div main-title>[[computeTitle(hasViews, locationName)]]</div>
          <paper-icon-button
            icon="mdi:refresh"
            class$="[[computeRefreshButtonClass(isFetching)]]"
            on-tap="handleRefresh" hidden$="[[isStreaming]]"
          ></paper-icon-button>
          <paper-icon-button
            icon="mdi:microphone" hidden$='[[!canListen]]'
            on-tap="handleListenClick"></paper-icon-button>
        </app-toolbar>

        <ha-view-tabs
          sticky
          hass='[[hass]]'
          on-view-tapped='scrollToTop'
        ></ha-view-tabs>
      </app-header>

      <ha-cards
        show-introduction='[[computeShowIntroduction(currentView, introductionLoaded, states)]]'
        states='[[states]]' columns='[[columns]]' hass='[[hass]]'
      ></ha-cards>
    </app-header-layout>
  </template>

</dom-module>

<script>
Polymer({
  is: 'partial-cards',

  behaviors: [window.hassBehavior],

  properties: {
    hass: {
      type: Object,
    },

    narrow: {
      type: Boolean,
      value: false,
    },

    isFetching: {
      type: Boolean,
      bindNuclear: function (hass) {
        return hass.syncGetters.isFetching;
      },
    },

    isStreaming: {
      type: Boolean,
      bindNuclear: function (hass) {
        return hass.streamGetters.isStreamingEvents;
      },
    },

    canListen: {
      type: Boolean,
      bindNuclear: function (hass) {
        return [
          hass.voiceGetters.isVoiceSupported,
          hass.configGetters.isComponentLoaded('conversation'),
          function (isVoiceSupported, componentLoaded) {
            return isVoiceSupported && componentLoaded;
          },
        ];
      },
    },

    introductionLoaded: {
      type: Boolean,
      bindNuclear: function (hass) {
        return hass.configGetters.isComponentLoaded('introduction');
      },
    },

    locationName: {
      type: String,
      bindNuclear: function (hass) {
        return hass.configGetters.locationName;
      },
    },

    showMenu: {
      type: Boolean,
      value: false,
      observer: 'windowChange',
    },

    currentView: {
      type: String,
      bindNuclear: function (hass) {
        return [
          hass.viewGetters.currentView,
          function (view) { return view || ''; },
        ];
      },
    },

    hasViews: {
      type: Boolean,
      bindNuclear: function (hass) {
        return [
          hass.viewGetters.views,
          function (views) { return views.size > 0; },
        ];
      },
    },

    states: {
      type: Object,
      bindNuclear: function (hass) {
        return hass.viewGetters.currentViewEntities;
      },
    },

    columns: {
      type: Number,
      value: 1,
    },
  },

  created: function () {
    var sizes = [];
    var col;
    this.windowChange = this.windowChange.bind(this);
    for (col = 0; col < 5; col++) {
      sizes.push(300 + (col * 300));
    }
    this.mqls = sizes.map(function (width) {
      var mql = window.matchMedia('(min-width: ' + width + 'px)');
      mql.addListener(this.windowChange);
      return mql;
    }.bind(this));
  },

  detached: function () {
    this.mqls.forEach(function (mql) {
      mql.removeListener(this.windowChange);
    });
  },

  windowChange: function () {
    var matchColumns = this.mqls.reduce(function (cols, mql) { return cols + mql.matches; }, 0);
    // Do -1 column if the menu is docked and open
    this.columns = Math.max(1, matchColumns - (!this.narrow && this.showMenu));
  },

  /**
   * Scroll to a specific y coordinate.
   *
   * Copied from paper-scroll-header-panel.
   *
   * @method scroll
   * @param {number} top The coordinate to scroll to, along the y-axis.
   * @param {boolean} smooth true if the scroll position should be smoothly adjusted.
   */
  scrollToTop: function () {
    // the scroll event will trigger _updateScrollState directly,
    // However, _updateScrollState relies on the previous `scrollTop` to update the states.
    // Calling _updateScrollState will ensure that the states are synced correctly.
    var top = 0;
    var scroller = this.$.layout.header.scrollTarget;
    var easingFn = function easeOutQuad(t, b, c, d) {
      /* eslint-disable no-param-reassign, space-infix-ops, no-mixed-operators */
      t /= d;
      return -c * t*(t-2) + b;
      /* eslint-enable no-param-reassign, space-infix-ops, no-mixed-operators */
    };
    var animationId = Math.random();
    var duration = 200;
    var startTime = Date.now();
    var currentScrollTop = scroller.scrollTop;
    var deltaScrollTop = top - currentScrollTop;
    this._currentAnimationId = animationId;
    (function updateFrame() {
      var now = Date.now();
      var elapsedTime = now - startTime;
      if (elapsedTime > duration) {
        scroller.scrollTop = top;
      } else if (this._currentAnimationId === animationId) {
        scroller.scrollTop = easingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration);
        requestAnimationFrame(updateFrame.bind(this));
      }
    }).call(this);
  },

  handleRefresh: function () {
    this.hass.syncActions.fetchAll();
  },

  handleListenClick: function () {
    this.hass.voiceActions.listen();
  },

  computeMenuButtonClass: function (narrow, showMenu) {
    return !narrow && showMenu ? 'menu-icon invisible' : 'menu-icon';
  },

  computeRefreshButtonClass: function (isFetching) {
    return isFetching ? 'ha-spin' : '';
  },

  computeTitle: function (hasViews, locationName) {
    return hasViews ? 'Home Assistant' : locationName;
  },

  computeShowIntroduction: function (currentView, introductionLoaded, states) {
    return currentView === '' && (introductionLoaded || states.size === 0);
  },

  computeHasViews: function (views) {
    return views.length > 0;
  },
});
</script>
